{
    "archivos": [
        {
            "metadata": {
                "path": ".git/COMMIT_EDITMSG",
                "size_bytes": 3,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "XD"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/HEAD",
                "size_bytes": 21,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "ref: refs/heads/main"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/config",
                "size_bytes": 130,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 7,
                "dependencias": null
            },
            "content_lines": [
                "[core]",
                "\trepositoryformatversion = 0",
                "\tfilemode = false",
                "\tbare = false",
                "\tlogallrefupdates = true",
                "\tsymlinks = false",
                "\tignorecase = true"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/description",
                "size_bytes": 73,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "Unnamed repository; edit this file 'description' to name the repository."
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/applypatch-msg.sample",
                "size_bytes": 478,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 15,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to check the commit log message taken by",
                "# applypatch from an e-mail message.",
                "#",
                "# The hook should exit with non-zero status after issuing an",
                "# appropriate message if it wants to stop the commit.  The hook is",
                "# allowed to edit the commit message file.",
                "#",
                "# To enable this hook, rename this file to \"applypatch-msg\".",
                "",
                ". git-sh-setup",
                "commitmsg=\"$(git rev-parse --git-path hooks/commit-msg)\"",
                "test -x \"$commitmsg\" && exec \"$commitmsg\" ${1+\"$@\"}",
                ":"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/commit-msg.sample",
                "size_bytes": 896,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 24,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to check the commit log message.",
                "# Called by \"git commit\" with one argument, the name of the file",
                "# that has the commit message.  The hook should exit with non-zero",
                "# status after issuing an appropriate message if it wants to stop the",
                "# commit.  The hook is allowed to edit the commit message file.",
                "#",
                "# To enable this hook, rename this file to \"commit-msg\".",
                "",
                "# Uncomment the below to add a Signed-off-by line to the message.",
                "# Doing this in a hook is a bad idea in general, but the prepare-commit-msg",
                "# hook is more suited to it.",
                "#",
                "# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')",
                "# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"",
                "",
                "# This example catches duplicate Signed-off-by lines.",
                "",
                "test \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |",
                "\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {",
                "\techo >&2 Duplicate Signed-off-by lines.",
                "\texit 1",
                "}"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/fsmonitor-watchman.sample",
                "size_bytes": 4726,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 174,
                "dependencias": null
            },
            "content_lines": [
                "#!/usr/bin/perl",
                "",
                "use strict;",
                "use warnings;",
                "use IPC::Open2;",
                "",
                "# An example hook script to integrate Watchman",
                "# (https://facebook.github.io/watchman/) with git to speed up detecting",
                "# new and modified files.",
                "#",
                "# The hook is passed a version (currently 2) and last update token",
                "# formatted as a string and outputs to stdout a new update token and",
                "# all files that have been modified since the update token. Paths must",
                "# be relative to the root of the working tree and separated by a single NUL.",
                "#",
                "# To enable this hook, rename this file to \"query-watchman\" and set",
                "# 'git config core.fsmonitor .git/hooks/query-watchman'",
                "#",
                "my ($version, $last_update_token) = @ARGV;",
                "",
                "# Uncomment for debugging",
                "# print STDERR \"$0 $version $last_update_token\\n\";",
                "",
                "# Check the hook interface version",
                "if ($version ne 2) {",
                "\tdie \"Unsupported query-fsmonitor hook version '$version'.\\n\" .",
                "\t    \"Falling back to scanning...\\n\";",
                "}",
                "",
                "my $git_work_tree = get_working_dir();",
                "",
                "my $retry = 1;",
                "",
                "my $json_pkg;",
                "eval {",
                "\trequire JSON::XS;",
                "\t$json_pkg = \"JSON::XS\";",
                "\t1;",
                "} or do {",
                "\trequire JSON::PP;",
                "\t$json_pkg = \"JSON::PP\";",
                "};",
                "",
                "launch_watchman();",
                "",
                "sub launch_watchman {",
                "\tmy $o = watchman_query();",
                "\tif (is_work_tree_watched($o)) {",
                "\t\toutput_result($o->{clock}, @{$o->{files}});",
                "\t}",
                "}",
                "",
                "sub output_result {",
                "\tmy ($clockid, @files) = @_;",
                "",
                "\t# Uncomment for debugging watchman output",
                "\t# open (my $fh, \">\", \".git/watchman-output.out\");",
                "\t# binmode $fh, \":utf8\";",
                "\t# print $fh \"$clockid\\n@files\\n\";",
                "\t# close $fh;",
                "",
                "\tbinmode STDOUT, \":utf8\";",
                "\tprint $clockid;",
                "\tprint \"\\0\";",
                "\tlocal $, = \"\\0\";",
                "\tprint @files;",
                "}",
                "",
                "sub watchman_clock {",
                "\tmy $response = qx/watchman clock \"$git_work_tree\"/;",
                "\tdie \"Failed to get clock id on '$git_work_tree'.\\n\" .",
                "\t\t\"Falling back to scanning...\\n\" if $? != 0;",
                "",
                "\treturn $json_pkg->new->utf8->decode($response);",
                "}",
                "",
                "sub watchman_query {",
                "\tmy $pid = open2(\\*CHLD_OUT, \\*CHLD_IN, 'watchman -j --no-pretty')",
                "\tor die \"open2() failed: $!\\n\" .",
                "\t\"Falling back to scanning...\\n\";",
                "",
                "\t# In the query expression below we're asking for names of files that",
                "\t# changed since $last_update_token but not from the .git folder.",
                "\t#",
                "\t# To accomplish this, we're using the \"since\" generator to use the",
                "\t# recency index to select candidate nodes and \"fields\" to limit the",
                "\t# output to file names only. Then we're using the \"expression\" term to",
                "\t# further constrain the results.",
                "\tmy $last_update_line = \"\";",
                "\tif (substr($last_update_token, 0, 1) eq \"c\") {",
                "\t\t$last_update_token = \"\\\"$last_update_token\\\"\";",
                "\t\t$last_update_line = qq[\\n\"since\": $last_update_token,];",
                "\t}",
                "\tmy $query = <<\"\tEND\";",
                "\t\t[\"query\", \"$git_work_tree\", {$last_update_line",
                "\t\t\t\"fields\": [\"name\"],",
                "\t\t\t\"expression\": [\"not\", [\"dirname\", \".git\"]]",
                "\t\t}]",
                "\tEND",
                "",
                "\t# Uncomment for debugging the watchman query",
                "\t# open (my $fh, \">\", \".git/watchman-query.json\");",
                "\t# print $fh $query;",
                "\t# close $fh;",
                "",
                "\tprint CHLD_IN $query;",
                "\tclose CHLD_IN;",
                "\tmy $response = do {local $/; <CHLD_OUT>};",
                "",
                "\t# Uncomment for debugging the watch response",
                "\t# open ($fh, \">\", \".git/watchman-response.json\");",
                "\t# print $fh $response;",
                "\t# close $fh;",
                "",
                "\tdie \"Watchman: command returned no output.\\n\" .",
                "\t\"Falling back to scanning...\\n\" if $response eq \"\";",
                "\tdie \"Watchman: command returned invalid output: $response\\n\" .",
                "\t\"Falling back to scanning...\\n\" unless $response =~ /^\\{/;",
                "",
                "\treturn $json_pkg->new->utf8->decode($response);",
                "}",
                "",
                "sub is_work_tree_watched {",
                "\tmy ($output) = @_;",
                "\tmy $error = $output->{error};",
                "\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {",
                "\t\t$retry--;",
                "\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;",
                "\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .",
                "\t\t    \"Falling back to scanning...\\n\" if $? != 0;",
                "\t\t$output = $json_pkg->new->utf8->decode($response);",
                "\t\t$error = $output->{error};",
                "\t\tdie \"Watchman: $error.\\n\" .",
                "\t\t\"Falling back to scanning...\\n\" if $error;",
                "",
                "\t\t# Uncomment for debugging watchman output",
                "\t\t# open (my $fh, \">\", \".git/watchman-output.out\");",
                "\t\t# close $fh;",
                "",
                "\t\t# Watchman will always return all files on the first query so",
                "\t\t# return the fast \"everything is dirty\" flag to git and do the",
                "\t\t# Watchman query just to get it over with now so we won't pay",
                "\t\t# the cost in git to look up each individual file.",
                "\t\tmy $o = watchman_clock();",
                "\t\t$error = $output->{error};",
                "",
                "\t\tdie \"Watchman: $error.\\n\" .",
                "\t\t\"Falling back to scanning...\\n\" if $error;",
                "",
                "\t\toutput_result($o->{clock}, (\"/\"));",
                "\t\t$last_update_token = $o->{clock};",
                "",
                "\t\teval { launch_watchman() };",
                "\t\treturn 0;",
                "\t}",
                "",
                "\tdie \"Watchman: $error.\\n\" .",
                "\t\"Falling back to scanning...\\n\" if $error;",
                "",
                "\treturn 1;",
                "}",
                "",
                "sub get_working_dir {",
                "\tmy $working_dir;",
                "\tif ($^O =~ 'msys' || $^O =~ 'cygwin') {",
                "\t\t$working_dir = Win32::GetCwd();",
                "\t\t$working_dir =~ tr/\\\\/\\//;",
                "\t} else {",
                "\t\trequire Cwd;",
                "\t\t$working_dir = Cwd::cwd();",
                "\t}",
                "",
                "\treturn $working_dir;",
                "}"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/post-update.sample",
                "size_bytes": 189,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 8,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to prepare a packed repository for use over",
                "# dumb transports.",
                "#",
                "# To enable this hook, rename this file to \"post-update\".",
                "",
                "exec git update-server-info"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-applypatch.sample",
                "size_bytes": 424,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 14,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to verify what is about to be committed",
                "# by applypatch from an e-mail message.",
                "#",
                "# The hook should exit with non-zero status after issuing an",
                "# appropriate message if it wants to stop the commit.",
                "#",
                "# To enable this hook, rename this file to \"pre-applypatch\".",
                "",
                ". git-sh-setup",
                "precommit=\"$(git rev-parse --git-path hooks/pre-commit)\"",
                "test -x \"$precommit\" && exec \"$precommit\" ${1+\"$@\"}",
                ":"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-commit.sample",
                "size_bytes": 1649,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 49,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to verify what is about to be committed.",
                "# Called by \"git commit\" with no arguments.  The hook should",
                "# exit with non-zero status after issuing an appropriate message if",
                "# it wants to stop the commit.",
                "#",
                "# To enable this hook, rename this file to \"pre-commit\".",
                "",
                "if git rev-parse --verify HEAD >/dev/null 2>&1",
                "then",
                "\tagainst=HEAD",
                "else",
                "\t# Initial commit: diff against an empty tree object",
                "\tagainst=$(git hash-object -t tree /dev/null)",
                "fi",
                "",
                "# If you want to allow non-ASCII filenames set this variable to true.",
                "allownonascii=$(git config --type=bool hooks.allownonascii)",
                "",
                "# Redirect output to stderr.",
                "exec 1>&2",
                "",
                "# Cross platform projects tend to avoid non-ASCII filenames; prevent",
                "# them from being added to the repository. We exploit the fact that the",
                "# printable range starts at the space character and ends with tilde.",
                "if [ \"$allownonascii\" != \"true\" ] &&",
                "\t# Note that the use of brackets around a tr range is ok here, (it's",
                "\t# even required, for portability to Solaris 10's /usr/bin/tr), since",
                "\t# the square bracket bytes happen to fall in the designated range.",
                "\ttest $(git diff-index --cached --name-only --diff-filter=A -z $against |",
                "\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0",
                "then",
                "\tcat <<\\EOF",
                "Error: Attempt to add a non-ASCII file name.",
                "",
                "This can cause problems if you want to work with people on other platforms.",
                "",
                "To be portable it is advisable to rename the file.",
                "",
                "If you know what you are doing you can disable this check using:",
                "",
                "  git config hooks.allownonascii true",
                "EOF",
                "\texit 1",
                "fi",
                "",
                "# If there are whitespace errors, print the offending file names and fail.",
                "exec git diff-index --check --cached $against --"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-merge-commit.sample",
                "size_bytes": 416,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 13,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to verify what is about to be committed.",
                "# Called by \"git merge\" with no arguments.  The hook should",
                "# exit with non-zero status after issuing an appropriate message to",
                "# stderr if it wants to stop the merge commit.",
                "#",
                "# To enable this hook, rename this file to \"pre-merge-commit\".",
                "",
                ". git-sh-setup",
                "test -x \"$GIT_DIR/hooks/pre-commit\" &&",
                "        exec \"$GIT_DIR/hooks/pre-commit\"",
                ":"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-push.sample",
                "size_bytes": 1374,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 53,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "",
                "# An example hook script to verify what is about to be pushed.  Called by \"git",
                "# push\" after it has checked the remote status, but before anything has been",
                "# pushed.  If this script exits with a non-zero status nothing will be pushed.",
                "#",
                "# This hook is called with the following parameters:",
                "#",
                "# $1 -- Name of the remote to which the push is being done",
                "# $2 -- URL to which the push is being done",
                "#",
                "# If pushing without using a named remote those arguments will be equal.",
                "#",
                "# Information about the commits which are being pushed is supplied as lines to",
                "# the standard input in the form:",
                "#",
                "#   <local ref> <local oid> <remote ref> <remote oid>",
                "#",
                "# This sample shows how to prevent push of commits where the log message starts",
                "# with \"WIP\" (work in progress).",
                "",
                "remote=\"$1\"",
                "url=\"$2\"",
                "",
                "zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')",
                "",
                "while read local_ref local_oid remote_ref remote_oid",
                "do",
                "\tif test \"$local_oid\" = \"$zero\"",
                "\tthen",
                "\t\t# Handle delete",
                "\t\t:",
                "\telse",
                "\t\tif test \"$remote_oid\" = \"$zero\"",
                "\t\tthen",
                "\t\t\t# New branch, examine all commits",
                "\t\t\trange=\"$local_oid\"",
                "\t\telse",
                "\t\t\t# Update to existing branch, examine new commits",
                "\t\t\trange=\"$remote_oid..$local_oid\"",
                "\t\tfi",
                "",
                "\t\t# Check for WIP commit",
                "\t\tcommit=$(git rev-list -n 1 --grep '^WIP' \"$range\")",
                "\t\tif test -n \"$commit\"",
                "\t\tthen",
                "\t\t\techo >&2 \"Found WIP commit in $local_ref, not pushing\"",
                "\t\t\texit 1",
                "\t\tfi",
                "\tfi",
                "done",
                "",
                "exit 0"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-rebase.sample",
                "size_bytes": 4898,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 169,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# Copyright (c) 2006, 2008 Junio C Hamano",
                "#",
                "# The \"pre-rebase\" hook is run just before \"git rebase\" starts doing",
                "# its job, and can prevent the command from running by exiting with",
                "# non-zero status.",
                "#",
                "# The hook is called with the following parameters:",
                "#",
                "# $1 -- the upstream the series was forked from.",
                "# $2 -- the branch being rebased (or empty when rebasing the current branch).",
                "#",
                "# This sample shows how to prevent topic branches that are already",
                "# merged to 'next' branch from getting rebased, because allowing it",
                "# would result in rebasing already published history.",
                "",
                "publish=next",
                "basebranch=\"$1\"",
                "if test \"$#\" = 2",
                "then",
                "\ttopic=\"refs/heads/$2\"",
                "else",
                "\ttopic=`git symbolic-ref HEAD` ||",
                "\texit 0 ;# we do not interrupt rebasing detached HEAD",
                "fi",
                "",
                "case \"$topic\" in",
                "refs/heads/??/*)",
                "\t;;",
                "*)",
                "\texit 0 ;# we do not interrupt others.",
                "\t;;",
                "esac",
                "",
                "# Now we are dealing with a topic branch being rebased",
                "# on top of master.  Is it OK to rebase it?",
                "",
                "# Does the topic really exist?",
                "git show-ref -q \"$topic\" || {",
                "\techo >&2 \"No such branch $topic\"",
                "\texit 1",
                "}",
                "",
                "# Is topic fully merged to master?",
                "not_in_master=`git rev-list --pretty=oneline ^master \"$topic\"`",
                "if test -z \"$not_in_master\"",
                "then",
                "\techo >&2 \"$topic is fully merged to master; better remove it.\"",
                "\texit 1 ;# we could allow it, but there is no point.",
                "fi",
                "",
                "# Is topic ever merged to next?  If so you should not be rebasing it.",
                "only_next_1=`git rev-list ^master \"^$topic\" ${publish} | sort`",
                "only_next_2=`git rev-list ^master           ${publish} | sort`",
                "if test \"$only_next_1\" = \"$only_next_2\"",
                "then",
                "\tnot_in_topic=`git rev-list \"^$topic\" master`",
                "\tif test -z \"$not_in_topic\"",
                "\tthen",
                "\t\techo >&2 \"$topic is already up to date with master\"",
                "\t\texit 1 ;# we could allow it, but there is no point.",
                "\telse",
                "\t\texit 0",
                "\tfi",
                "else",
                "\tnot_in_next=`git rev-list --pretty=oneline ^${publish} \"$topic\"`",
                "\t/usr/bin/perl -e '",
                "\t\tmy $topic = $ARGV[0];",
                "\t\tmy $msg = \"* $topic has commits already merged to public branch:\\n\";",
                "\t\tmy (%not_in_next) = map {",
                "\t\t\t/^([0-9a-f]+) /;",
                "\t\t\t($1 => 1);",
                "\t\t} split(/\\n/, $ARGV[1]);",
                "\t\tfor my $elem (map {",
                "\t\t\t\t/^([0-9a-f]+) (.*)$/;",
                "\t\t\t\t[$1 => $2];",
                "\t\t\t} split(/\\n/, $ARGV[2])) {",
                "\t\t\tif (!exists $not_in_next{$elem->[0]}) {",
                "\t\t\t\tif ($msg) {",
                "\t\t\t\t\tprint STDERR $msg;",
                "\t\t\t\t\tundef $msg;",
                "\t\t\t\t}",
                "\t\t\t\tprint STDERR \" $elem->[1]\\n\";",
                "\t\t\t}",
                "\t\t}",
                "\t' \"$topic\" \"$not_in_next\" \"$not_in_master\"",
                "\texit 1",
                "fi",
                "",
                "<<\\DOC_END",
                "",
                "This sample hook safeguards topic branches that have been",
                "published from being rewound.",
                "",
                "The workflow assumed here is:",
                "",
                " * Once a topic branch forks from \"master\", \"master\" is never",
                "   merged into it again (either directly or indirectly).",
                "",
                " * Once a topic branch is fully cooked and merged into \"master\",",
                "   it is deleted.  If you need to build on top of it to correct",
                "   earlier mistakes, a new topic branch is created by forking at",
                "   the tip of the \"master\".  This is not strictly necessary, but",
                "   it makes it easier to keep your history simple.",
                "",
                " * Whenever you need to test or publish your changes to topic",
                "   branches, merge them into \"next\" branch.",
                "",
                "The script, being an example, hardcodes the publish branch name",
                "to be \"next\", but it is trivial to make it configurable via",
                "$GIT_DIR/config mechanism.",
                "",
                "With this workflow, you would want to know:",
                "",
                "(1) ... if a topic branch has ever been merged to \"next\".  Young",
                "    topic branches can have stupid mistakes you would rather",
                "    clean up before publishing, and things that have not been",
                "    merged into other branches can be easily rebased without",
                "    affecting other people.  But once it is published, you would",
                "    not want to rewind it.",
                "",
                "(2) ... if a topic branch has been fully merged to \"master\".",
                "    Then you can delete it.  More importantly, you should not",
                "    build on top of it -- other people may already want to",
                "    change things related to the topic as patches against your",
                "    \"master\", so if you need further changes, it is better to",
                "    fork the topic (perhaps with the same name) afresh from the",
                "    tip of \"master\".",
                "",
                "Let's look at this example:",
                "",
                "\t\t   o---o---o---o---o---o---o---o---o---o \"next\"",
                "\t\t  /       /           /           /",
                "\t\t /   a---a---b A     /           /",
                "\t\t/   /               /           /",
                "\t       /   /   c---c---c---c B         /",
                "\t      /   /   /             \\         /",
                "\t     /   /   /   b---b C     \\       /",
                "\t    /   /   /   /             \\     /",
                "    ---o---o---o---o---o---o---o---o---o---o---o \"master\"",
                "",
                "",
                "A, B and C are topic branches.",
                "",
                " * A has one fix since it was merged up to \"next\".",
                "",
                " * B has finished.  It has been fully merged up to \"master\" and \"next\",",
                "   and is ready to be deleted.",
                "",
                " * C has not merged to \"next\" at all.",
                "",
                "We would want to allow C to be rebased, refuse A, and encourage",
                "B to be deleted.",
                "",
                "To compute (1):",
                "",
                "\tgit rev-list ^master ^topic next",
                "\tgit rev-list ^master        next",
                "",
                "\tif these match, topic has not merged in next at all.",
                "",
                "To compute (2):",
                "",
                "\tgit rev-list master..topic",
                "",
                "\tif this is empty, it is fully merged to \"master\".",
                "",
                "DOC_END"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/pre-receive.sample",
                "size_bytes": 544,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 24,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to make use of push options.",
                "# The example simply echoes all push options that start with 'echoback='",
                "# and rejects all pushes when the \"reject\" push option is used.",
                "#",
                "# To enable this hook, rename this file to \"pre-receive\".",
                "",
                "if test -n \"$GIT_PUSH_OPTION_COUNT\"",
                "then",
                "\ti=0",
                "\twhile test \"$i\" -lt \"$GIT_PUSH_OPTION_COUNT\"",
                "\tdo",
                "\t\teval \"value=\\$GIT_PUSH_OPTION_$i\"",
                "\t\tcase \"$value\" in",
                "\t\techoback=*)",
                "\t\t\techo \"echo from the pre-receive-hook: ${value#*=}\" >&2",
                "\t\t\t;;",
                "\t\treject)",
                "\t\t\texit 1",
                "\t\tesac",
                "\t\ti=$((i + 1))",
                "\tdone",
                "fi"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/prepare-commit-msg.sample",
                "size_bytes": 1492,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 42,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to prepare the commit log message.",
                "# Called by \"git commit\" with the name of the file that has the",
                "# commit message, followed by the description of the commit",
                "# message's source.  The hook's purpose is to edit the commit",
                "# message file.  If the hook fails with a non-zero status,",
                "# the commit is aborted.",
                "#",
                "# To enable this hook, rename this file to \"prepare-commit-msg\".",
                "",
                "# This hook includes three examples. The first one removes the",
                "# \"# Please enter the commit message...\" help message.",
                "#",
                "# The second includes the output of \"git diff --name-status -r\"",
                "# into the message, just before the \"git status\" output.  It is",
                "# commented because it doesn't cope with --amend or with squashed",
                "# commits.",
                "#",
                "# The third example adds a Signed-off-by line to the message, that can",
                "# still be edited.  This is rarely a good idea.",
                "",
                "COMMIT_MSG_FILE=$1",
                "COMMIT_SOURCE=$2",
                "SHA1=$3",
                "",
                "/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' \"$COMMIT_MSG_FILE\"",
                "",
                "# case \"$COMMIT_SOURCE,$SHA1\" in",
                "#  ,|template,)",
                "#    /usr/bin/perl -i.bak -pe '",
                "#       print \"\\n\" . `git diff --cached --name-status -r`",
                "# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;",
                "#  *) ;;",
                "# esac",
                "",
                "# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')",
                "# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"",
                "# if test -z \"$COMMIT_SOURCE\"",
                "# then",
                "#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"",
                "# fi"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/push-to-checkout.sample",
                "size_bytes": 2783,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 78,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "",
                "# An example hook script to update a checked-out tree on a git push.",
                "#",
                "# This hook is invoked by git-receive-pack(1) when it reacts to git",
                "# push and updates reference(s) in its repository, and when the push",
                "# tries to update the branch that is currently checked out and the",
                "# receive.denyCurrentBranch configuration variable is set to",
                "# updateInstead.",
                "#",
                "# By default, such a push is refused if the working tree and the index",
                "# of the remote repository has any difference from the currently",
                "# checked out commit; when both the working tree and the index match",
                "# the current commit, they are updated to match the newly pushed tip",
                "# of the branch. This hook is to be used to override the default",
                "# behaviour; however the code below reimplements the default behaviour",
                "# as a starting point for convenient modification.",
                "#",
                "# The hook receives the commit with which the tip of the current",
                "# branch is going to be updated:",
                "commit=$1",
                "",
                "# It can exit with a non-zero status to refuse the push (when it does",
                "# so, it must not modify the index or the working tree).",
                "die () {",
                "\techo >&2 \"$*\"",
                "\texit 1",
                "}",
                "",
                "# Or it can make any necessary changes to the working tree and to the",
                "# index to bring them to the desired state when the tip of the current",
                "# branch is updated to the new commit, and exit with a zero status.",
                "#",
                "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"",
                "# in order to emulate git fetch that is run in the reverse direction",
                "# with git push, as the two-tree form of git read-tree -u -m is",
                "# essentially the same as git switch or git checkout that switches",
                "# branches while keeping the local changes in the working tree that do",
                "# not interfere with the difference between the branches.",
                "",
                "# The below is a more-or-less exact translation to shell of the C code",
                "# for the default behaviour for git's push-to-checkout hook defined in",
                "# the push_to_deploy() function in builtin/receive-pack.c.",
                "#",
                "# Note that the hook will be executed from the repository directory,",
                "# not from the working tree, so if you want to perform operations on",
                "# the working tree, you will have to adapt your code accordingly, e.g.",
                "# by adding \"cd ..\" or using relative paths.",
                "",
                "if ! git update-index -q --ignore-submodules --refresh",
                "then",
                "\tdie \"Up-to-date check failed\"",
                "fi",
                "",
                "if ! git diff-files --quiet --ignore-submodules --",
                "then",
                "\tdie \"Working directory has unstaged changes\"",
                "fi",
                "",
                "# This is a rough translation of:",
                "#",
                "#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX",
                "if git cat-file -e HEAD 2>/dev/null",
                "then",
                "\thead=HEAD",
                "else",
                "\thead=$(git hash-object -t tree --stdin </dev/null)",
                "fi",
                "",
                "if ! git diff-index --quiet --cached --ignore-submodules $head --",
                "then",
                "\tdie \"Working directory has staged changes\"",
                "fi",
                "",
                "if ! git read-tree -u -m \"$commit\"",
                "then",
                "\tdie \"Could not update working tree to new HEAD\"",
                "fi"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/sendemail-validate.sample",
                "size_bytes": 2308,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 77,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "",
                "# An example hook script to validate a patch (and/or patch series) before",
                "# sending it via email.",
                "#",
                "# The hook should exit with non-zero status after issuing an appropriate",
                "# message if it wants to prevent the email(s) from being sent.",
                "#",
                "# To enable this hook, rename this file to \"sendemail-validate\".",
                "#",
                "# By default, it will only check that the patch(es) can be applied on top of",
                "# the default upstream branch without conflicts in a secondary worktree. After",
                "# validation (successful or not) of the last patch of a series, the worktree",
                "# will be deleted.",
                "#",
                "# The following config variables can be set to change the default remote and",
                "# remote ref that are used to apply the patches against:",
                "#",
                "#   sendemail.validateRemote (default: origin)",
                "#   sendemail.validateRemoteRef (default: HEAD)",
                "#",
                "# Replace the TODO placeholders with appropriate checks according to your",
                "# needs.",
                "",
                "validate_cover_letter () {",
                "\tfile=\"$1\"",
                "\t# TODO: Replace with appropriate checks (e.g. spell checking).",
                "\ttrue",
                "}",
                "",
                "validate_patch () {",
                "\tfile=\"$1\"",
                "\t# Ensure that the patch applies without conflicts.",
                "\tgit am -3 \"$file\" || return",
                "\t# TODO: Replace with appropriate checks for this patch",
                "\t# (e.g. checkpatch.pl).",
                "\ttrue",
                "}",
                "",
                "validate_series () {",
                "\t# TODO: Replace with appropriate checks for the whole series",
                "\t# (e.g. quick build, coding style checks, etc.).",
                "\ttrue",
                "}",
                "",
                "# main -------------------------------------------------------------------------",
                "",
                "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1",
                "then",
                "\tremote=$(git config --default origin --get sendemail.validateRemote) &&",
                "\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&",
                "\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&",
                "\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&",
                "\tgit config --replace-all sendemail.validateWorktree \"$worktree\"",
                "else",
                "\tworktree=$(git config --get sendemail.validateWorktree)",
                "fi || {",
                "\techo \"sendemail-validate: error: failed to prepare worktree\" >&2",
                "\texit 1",
                "}",
                "",
                "unset GIT_DIR GIT_WORK_TREE",
                "cd \"$worktree\" &&",
                "",
                "if grep -q \"^diff --git \" \"$1\"",
                "then",
                "\tvalidate_patch \"$1\"",
                "else",
                "\tvalidate_cover_letter \"$1\"",
                "fi &&",
                "",
                "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"",
                "then",
                "\tgit config --unset-all sendemail.validateWorktree &&",
                "\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&",
                "\tvalidate_series",
                "fi"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/hooks/update.sample",
                "size_bytes": 3650,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 128,
                "dependencias": null
            },
            "content_lines": [
                "#!/bin/sh",
                "#",
                "# An example hook script to block unannotated tags from entering.",
                "# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new",
                "#",
                "# To enable this hook, rename this file to \"update\".",
                "#",
                "# Config",
                "# ------",
                "# hooks.allowunannotated",
                "#   This boolean sets whether unannotated tags will be allowed into the",
                "#   repository.  By default they won't be.",
                "# hooks.allowdeletetag",
                "#   This boolean sets whether deleting tags will be allowed in the",
                "#   repository.  By default they won't be.",
                "# hooks.allowmodifytag",
                "#   This boolean sets whether a tag may be modified after creation. By default",
                "#   it won't be.",
                "# hooks.allowdeletebranch",
                "#   This boolean sets whether deleting branches will be allowed in the",
                "#   repository.  By default they won't be.",
                "# hooks.denycreatebranch",
                "#   This boolean sets whether remotely creating branches will be denied",
                "#   in the repository.  By default this is allowed.",
                "#",
                "",
                "# --- Command line",
                "refname=\"$1\"",
                "oldrev=\"$2\"",
                "newrev=\"$3\"",
                "",
                "# --- Safety check",
                "if [ -z \"$GIT_DIR\" ]; then",
                "\techo \"Don't run this script from the command line.\" >&2",
                "\techo \" (if you want, you could supply GIT_DIR then run\" >&2",
                "\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2",
                "\texit 1",
                "fi",
                "",
                "if [ -z \"$refname\" -o -z \"$oldrev\" -o -z \"$newrev\" ]; then",
                "\techo \"usage: $0 <ref> <oldrev> <newrev>\" >&2",
                "\texit 1",
                "fi",
                "",
                "# --- Config",
                "allowunannotated=$(git config --type=bool hooks.allowunannotated)",
                "allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)",
                "denycreatebranch=$(git config --type=bool hooks.denycreatebranch)",
                "allowdeletetag=$(git config --type=bool hooks.allowdeletetag)",
                "allowmodifytag=$(git config --type=bool hooks.allowmodifytag)",
                "",
                "# check for no description",
                "projectdesc=$(sed -e '1q' \"$GIT_DIR/description\")",
                "case \"$projectdesc\" in",
                "\"Unnamed repository\"* | \"\")",
                "\techo \"*** Project description file hasn't been set\" >&2",
                "\texit 1",
                "\t;;",
                "esac",
                "",
                "# --- Check types",
                "# if $newrev is 0000...0000, it's a commit to delete a ref.",
                "zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')",
                "if [ \"$newrev\" = \"$zero\" ]; then",
                "\tnewrev_type=delete",
                "else",
                "\tnewrev_type=$(git cat-file -t $newrev)",
                "fi",
                "",
                "case \"$refname\",\"$newrev_type\" in",
                "\trefs/tags/*,commit)",
                "\t\t# un-annotated tag",
                "\t\tshort_refname=${refname##refs/tags/}",
                "\t\tif [ \"$allowunannotated\" != \"true\" ]; then",
                "\t\t\techo \"*** The un-annotated tag, $short_refname, is not allowed in this repository\" >&2",
                "\t\t\techo \"*** Use 'git tag [ -a | -s ]' for tags you want to propagate.\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\trefs/tags/*,delete)",
                "\t\t# delete tag",
                "\t\tif [ \"$allowdeletetag\" != \"true\" ]; then",
                "\t\t\techo \"*** Deleting a tag is not allowed in this repository\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\trefs/tags/*,tag)",
                "\t\t# annotated tag",
                "\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1",
                "\t\tthen",
                "\t\t\techo \"*** Tag '$refname' already exists.\" >&2",
                "\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\trefs/heads/*,commit)",
                "\t\t# branch",
                "\t\tif [ \"$oldrev\" = \"$zero\" -a \"$denycreatebranch\" = \"true\" ]; then",
                "\t\t\techo \"*** Creating a branch is not allowed in this repository\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\trefs/heads/*,delete)",
                "\t\t# delete branch",
                "\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then",
                "\t\t\techo \"*** Deleting a branch is not allowed in this repository\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\trefs/remotes/*,commit)",
                "\t\t# tracking branch",
                "\t\t;;",
                "\trefs/remotes/*,delete)",
                "\t\t# delete tracking branch",
                "\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then",
                "\t\t\techo \"*** Deleting a tracking branch is not allowed in this repository\" >&2",
                "\t\t\texit 1",
                "\t\tfi",
                "\t\t;;",
                "\t*)",
                "\t\t# Anything else (is there anything else?)",
                "\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2",
                "\t\texit 1",
                "\t\t;;",
                "esac",
                "",
                "# --- Finished",
                "exit 0"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/index",
                "size_bytes": 2183,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/info/exclude",
                "size_bytes": 240,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 6,
                "dependencias": null
            },
            "content_lines": [
                "# git ls-files --others --exclude-from=.git/info/exclude",
                "# Lines that start with '#' are comments.",
                "# For a project mostly in C, the following would be a good set of",
                "# exclude patterns (uncomment them if you want to use them):",
                "# *.[oa]",
                "# *~"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/logs/HEAD",
                "size_bytes": 703,
                "status": "ok",
                "encoding": "utf-8",
                "language": "text",
                "line_count": 4,
                "dependencias": null
            },
            "content_lines": [
                "0000000000000000000000000000000000000000 a2f57f188a827f1f8157c973e85399073c4ee24c Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743328174 +0200\tcommit (initial): \"Tetris Funcional\"",
                "a2f57f188a827f1f8157c973e85399073c4ee24c 244952d72bd06354b5e42a2a9d5d633cade31c94 Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743330601 +0200\tcommit: Sonidos funcionales",
                "244952d72bd06354b5e42a2a9d5d633cade31c94 9db57ec4779b52c8d0efc01df31a4d7f6af95698 Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743331716 +0200\tcommit: \"Opcion mejoradas\"",
                "9db57ec4779b52c8d0efc01df31a4d7f6af95698 c6c615b4c114af8ab7be388ec973a4f0af9fe67e Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743539757 +0200\tcommit: XD"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/logs/refs/heads/main",
                "size_bytes": 703,
                "status": "ok",
                "encoding": "utf-8",
                "language": "text",
                "line_count": 4,
                "dependencias": null
            },
            "content_lines": [
                "0000000000000000000000000000000000000000 a2f57f188a827f1f8157c973e85399073c4ee24c Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743328174 +0200\tcommit (initial): \"Tetris Funcional\"",
                "a2f57f188a827f1f8157c973e85399073c4ee24c 244952d72bd06354b5e42a2a9d5d633cade31c94 Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743330601 +0200\tcommit: Sonidos funcionales",
                "244952d72bd06354b5e42a2a9d5d633cade31c94 9db57ec4779b52c8d0efc01df31a4d7f6af95698 Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743331716 +0200\tcommit: \"Opcion mejoradas\"",
                "9db57ec4779b52c8d0efc01df31a4d7f6af95698 c6c615b4c114af8ab7be388ec973a4f0af9fe67e Nº 08 <146817599+SMR-08@users.noreply.github.com> 1743539757 +0200\tcommit: XD"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/04/7a46877bea66db7472210ad8bc0c618679958a",
                "size_bytes": 480,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/09/a6b861f7555ed66e548b26db80f9fadae72649",
                "size_bytes": 158,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/0e/757d07b4f7b1f679b4073f91d677c4316b9675",
                "size_bytes": 304,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/18/f02fd76d5274e1d448dba3c0202c70f2e0cdef",
                "size_bytes": 2591,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/1a/1c63c1d91ce2e105d59e5b008be605496fe1ee",
                "size_bytes": 65,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/1f/2b676a2a2c31e335a23fa4693a36fb64d98579",
                "size_bytes": 1492,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/24/4952d72bd06354b5e42a2a9d5d633cade31c94",
                "size_bytes": 188,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/26/2928dace0bcfac8840690fd2236db76114799f",
                "size_bytes": 286,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 12,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001eÁJÃ@\u0014E]ç+.é¦\u0005«º\u0011]\u0004\u001bKM%ëòLËÈ$oI\u0004?ÃOð7ÜöÇL°¤ô­",
                "¼{î½¼BqÅÃâf\u0002kÊ{a[ªxÿÑ#ßé¯à`¸hº\u001a²ÖlZÄn¿\u0005u-\u0007A©ÈZÄ",
                "ÙôÄ´¿Î",
                "\u0003¸\tÃð]h#¬hZb",
                "ÍV\u0016JX",
                "!\u0016P\u0018ØCÛ8Éñìí§³ÞÅÍ\u0004[Ñ~¡lJ©Iõüé\u0007T¶ò=f/ë4w\u0017è?W\t°.%7CòÄÓ|>Gtúëeê}6ù*Jé",
                "Ë#WóH",
                "T²¢j",
                "O",
                "Ë¢|\u0017]cCm\u0017¯©³4Æ\u0018",
                "# ÈÝÜ{[ÎÿÂ;¾®ý&Wã*\u0013d#íA6g\u0004V îÜW",
                "ý\u0001)ý±"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/26/9d930cc6beb50f5cbff548333ff5947adf04a9",
                "size_bytes": 6567,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/2a/33d9171e4ff13d31d6b4beccb46ae5b60e2861",
                "size_bytes": 4083,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/2d/48810986092432e896f8dbcd50670583ea9a38",
                "size_bytes": 4369,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/33/775d159ce674702b50701ccffaab41c87718cf",
                "size_bytes": 279,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/3d/5b62aa1a06fc5ecbee50b1832f83c1be255e81",
                "size_bytes": 3355,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/45/9fedf0753a077bd2d82c6c3a3dc30059e879d8",
                "size_bytes": 3739,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/4f/24c46353d1f70f32f4fc8f075a2a5ab65787aa",
                "size_bytes": 29,
                "status": "read_error",
                "encoding": "cp1252",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/50/86a74ef84729e91ddfb708797a5db09e5d687e",
                "size_bytes": 1694,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/52/a773298679e39d5c35b3e3fd06fa116ae5cdf4",
                "size_bytes": 278,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/55/ba5b8c62fdf4b2a7a87e4194c4c6706f397e7c",
                "size_bytes": 4695,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 136,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001Å[{oÛÈ\u0011ïßù\u0014{6",
                "È­­Ø×öºõ\u0015®­ä8¶êÇ",
                "\u000eA@ÐÒJ&B:²­",
                "òÝû}l'w¨Ä\u0012¹;;ï½É\u001bµ÷Ýßÿþ?lªª",
                "½¦wº?_¾ÊîæEY«ù",
                "Ø_Õ²²_ëÌ?ÏËlV¿zµ©NdÖLtU¥åR",
                "<éY]½Åê+\u0003xTÌ&ÙT¥\u001aM¦æ",
                "-UÕi­í ·xpÉ\u000f",
                "èÅ|\u0001cå^¹ó",
                "kÚyCú±­¦ºNÊt6.î\u0012~m)³±",
                "Ù\u001b\u001að)m«¬JîÓ<\u001b'ó¢Êê¬m«¼\u0018}ÙÛ¯Tû3ÊuZ&y6ÓÕ¶\u001a¥ùh3¸Û¢ª",
                "-³ð¸L\u001f²ÙÔ­M¿ye3Ïót9Ét>Nnr¬Ëmå%7MÕb2í",
                "ÁAXÁ0fú\u0011H\u0005\u000f\u0016Ù\u001aXwi6KîôlaàÍÓE¥Ã\u0007ÅXTGê;;êp<\u0016LÂ]3TAÀIq¯KË¢ªXÌplÀNøÍ«W£<­*þ>",
                "ëJlÕIÒ«t>Ùç$ª\u0013¼È ÒÿêJ",
                "Y·\u0015CÂ\u001f×ðº­ 'À`´\"ET¬}Àpè×åÒ\u0003§\u0005Ä:úwÙ£.ûóR3",
                "½I©YèÙhyð×¿îíîb%,°³÷",
                "ÖºMg3W\u0007ßn«Åd¢Ë¿í}»åV\b\u0012.½Î7bV÷»^\u0015ö<É¤j:|s5¸°ØÊÌ~¿¿±¥6Õ;­çf\u0014½ ",
                "ëZwPé±ºÑ¢Ô\u0011z-&\u00048",
                "#x¯d\u0002\u0001ehI¥ë\u001aTêÀ\u0012 «qw0&fÆÜ}Å",
                "ª7ÙxO¢²rXÆê!«o]d_½ð\u000e~þ°ûñó¶zSwiÝz·Gï¬\\3¿ýøy#\u0016\"!\b",
                "Ð\u0016§ÁÅÅù\u0005~±v\u001a]òÄ©R×dq\u0006?úÍÆ¶d¹>'îW5Ü\u0003, Ú~",
                "é¹uÛ}¼.J\u0012)èIð#Ö^c\u0019c°x\u0002úXÕEÀ#aæ¾\"Ú\bÊç§\u0010ÀBÏ/",
                "Rã(BX?âûGx\u0005²:FÓaÈÄÈÙ I»Å¢\u0011dJ°óWý$b!\u0012mä4úâ",
                "¼³",
                "q\u001fÜ\u0015cÝë!Lõ/.\u0006³ä§ã«\u001f`ÌþÉ\u000f·?\\myÒ4C0£ýeoc¸¼ÒuUjG",
                "Uïáf\u0003=aØ/y(àöÈWÁ+8ä7Õ\u000e¼î%{ÍKhÊ~»·",
                "'pÖö©\u0011V\u0010°DÏÒ\u001bÒ\u0003uU.4",
                "",
                "õîâ¡íëIN\u0011\u001fô$]ä5\u000fmâFZI\u0010'\u0017Kò&äq\u0013ý\u0007>¶÷ß\u000fÎ®cjÊÅlF¢\u0017¼âw.b%&ú`Ô!ä\bÝ0¼¦¯ÿRn|'v=BfÁáÌ\u0000ÀüÝx\u000fÑ\u001a\u0017ºZÜi\u0002ý",
                "QSÄiÖajV.&ð\u0004Ýöj\u0010%ò\u001f6Xà\u0015­÷ïtôiã£Ï±Àm+K=\u0005oÕú®p¤Zø~ýPÐÌ\u0010Dx¸±~T\u0004\u0016rÉ\\ÔiÞtH4\u0017Üµ\u0015Ññëç\u0018/JÂð8HÉº9Z%IIb0|b",
                "Ãç8¯+ò\u0015xÓ\u0010k]Ôi.i\\Â)",
                "k~cP®ïu¹{ñ4Ïj®y",
                "ù³«ÃÓäÍáéir9",
                "",
                ";&9Gx\u0018ñIÓ)õ",
                "){wÁppx",
                "\u000fN\u000f\u0016Ï\u0013<=9CxÿñðÔ»\u001f6ä¤Ôä¾Ø´î­`z[6T\u00109ê",
                "H0âd",
                "Z®ëJ9X",
                "T²I6¢xrÖÄZP!ù'½é1··\u0015§ÈI¾[QFÅx®×V¾ÁsÐLõ\u0003Å!zyN¤\u001a­\tm°ýz9×§&Z",
                "8Â\u0012y««Bt\u001fL±",
                "¨\u001bÏW\u0014¤F:ßM\\kÈ¦ú\u0001Î7×ª¾EÜ È/Jý/õ>]Þh2ll8ç¥T\\ÁÎÙs°;þÓ]Zj² 5+",
                " Ô²\u0018Îß\u0016sòÇH",
                "¡EE~¯«¾Â<ý½M\u0017IüÞËÛc \u0004<ß´",
                "_u¸",
                "~ÞÔM\u0013zÙjüL\"ï>°a¤½ u\"±ý",
                "Ùýa",
                "Í\u0007ù¡´\u0002\u0007¡J<\t;\u0011l&ñ ­ñ",
                "\"¡xi¤¯ØùD¶,7ZKý\u0013n\u0017?\u0015¤z&Y9¿\u0018$ÃÁErzr6Ø7©eà",
                "\tÄÊKÒpÆ\br\u0010?\u0018$ãä¸+òj\u0001?í1úN/$§\u0015&¸y?òåy",
                "ûºõ­¹äÙÊn=fnÄB\u0007ÃïwÅ×¯qÄ®KaÜàÇÁéú3\u0000SÓP@÷H}VÆ÷°{¬sØ]UëùV|®\bu\u001bpîÒG\u000e\u0012ïOÎ#!¢",
                "r",
                "±\u0012ËvÔÞú\u0013è\u0015",
                "Ò\\d^WÞ÷Y\u0011Æ\u0001áØõÀ©@óEÝ!¤!¹",
                "Ñ@\u0011¹&YG\u0010E5u[j9U°ÝVé\bº4CÉ\u0011¹|ðLÒe\u0013*ùw\u001f®µ\u0017ð¼\u0014,CÞ\u0003W\u0007nãøë«xoA£ÙÎ}Zù&ÅæÌi*",
                " 0 z,©÷E± z\u0015qÀN\u0012Ù0É%\u0018@K|Më6Ý}\u0019\u0018Î\u001f6ìe¼D\b Î\u0002y>¼:9?»l@µiÈM\u0000\u0007_I$E¤>½ÐððúrpÜXGÛp\u0017B}{ø~ÿ8Àö9gÙÂ)",
                "Åª¯áÍ\u0010©ÔÉÙÛ\u0006hJ` ~1`FM½-\u0017Bl[ô-PC$âVF7ÂT<\u0016íl:JL«T\u0017ÙÞñùOg±öºÁH\u001a\u00035\\\u000fã¤,Ì@ü×µÉ\u0011Ðù]Ä\u001f\u0011~f2¨µÇêPI1¾&Rmü¿\u0002-8à-õ u1¸º¾8£¸Ùö»a\u0002W\b\u0015t×¡nU-U8Üp\u0005¯>¬\u0014ÂÇg³qpyt8",
                "´±\u0011\u00017ýXKscÛ'|¾@y[ù?ê¯%Ãí\\\u001b*ÜxßÔbû¥f~<[\u0002ÏQd»üEJ´",
                "¿¦:Ûé_ßWi´¸tD¥} Í",
                "Û",
                "MCí\u0010ùëSC²\u0013úH \u001f([ÇèÐfÌ\u0011ciT£(íx±©®é78ØÐ (Õ²VÂÂ\u0012¥|¢\u0006RãÂV¬",
                "\u0011e[Úí ß¹A",
                "¥\u0013Ú¦)ß¥ù¾¢\"\u0013¶À×'(Fâ`*ÅÄ@)ÝêF",
                "p±1µÅ\u0013®è¬á\b\u0007¿îR\u00190~[ ",
                "\u0019}¢",
                "9¹jÞÉub/$wÇ=\u0000:çÒ$\u0012·¥ºÍ¦·9þÕ¾Fêö£ëýÖz¢\u0006\u0015§Ø\u000fåU¡¦\u0005òÉnüf$µ¼fÉÐ*mébq#ç|qà6Úm\u0005Ó(\u00106ÜHô¶éääå\u0017¹\u0010vq_IÓ}\u0005&Ïvf­",
                "Ç²\"D\u0005órñ¸FÃÉ\u0000ãÃ",
                "\u000fD³Wg\u0010sb®Ðq¶·U<>ÈrOÅë8\u001abkZQCly\u0014",
                "ü\u0004äõìg£¸[ÍÉ/ö!-|\u001bº",
                "\u0018\t\u0017eÛ\u000e Ú\u0016üxZZÄ¬e>oÌº§`DPï~+&û·ÃÕKDo'ÛaËùÅævàtðæÊî½PãÅ)Û½îíìm«ÝØð\b",
                "5ÚrA\u0007o-8/\u0006ÓÓÑÚ\u0017J0\u0013)õL\u001ah? ç\u0018¤ºvð\u001aÊ®«",
                "á1¤¸ÄáE­{|^øUúNì^ÄÄÿ®\u0005Ç\u0015\u0017Á»",
                "",
                "",
                "¡¾(,»MËq2.9Ê±-»bÃ\u0013=´n\u001aý\u0012ÖmÇ\u001bêÁ£",
                "¡2Úd§®zê\u0012",
                "?3*",
                "ªJ$ }²",
                "\tÆº*¸v",
                "Ä¤óÀgz:®£´ªÚWZÒ\u0015¤ïÒ73\u000f\u0013£\u0003SÒuXÝYdó<^0Á!D¸*8åDÂÇ§;Th3ãâ$²(>O)â\u0005Üv",
                "énùû",
                "\u0004oL DàKg®FÍ)0í¶üm\u0007\t+àF\u0007ÓN ÁÍxbÍ½kyb",
                "\u0012\u001bRVsÍy\u001fâ.Ý\u001fño\u0019\u001bÉaóÞ9",
                "¬´\u0001ëÂ/óA\\\u001f¦JNöÉ8\u0016#ªÓN\u0016yÓlÜn+:r'\u0007q­tS",
                "©7%ß<76¡¼â°Ã\u0016Aq\u0016è4\u00148´Zï$ÓÖeÍô°»{Ø",
                "ËG·\u001a-|\u0007W\u0004¯ÿB>èðpsÂ/2Ù5IóC\u0001Ð¼îu\u000e°P´NÇ0Ã°e4L\"¯tVX¬Ì3á>æÚ$i\u0005\u0004",
                "g\u0000Ä)\u001f\u0011¼v£:\u0019êLjk",
                "\u001a\"g£|Aåxªmã÷",
                "ù24!¾LS",
                "IEM³\u0019ÎÚyM¶À.Ù·íy6\u00147$Ù",
                "h\u0017hÏÞ\u000e\t\u0018ö9ÆE6ÿ\u001fí\u000eÌäod¿©.ÑHzåz(JôWH¥$¥¤LøÈ",
                "=#=Î¶É±ð\u0005=»[ô¿ø",
                "µk¡\u0018\u0010Âñ\u001aD+(Äâ:!8©A9YøQ$",
                "7JÌ&",
                "µÎyÄ#¿ÒY \u0007Sü`\u000f+áßË\u0003þÝ4f¦ CQj\u0001\u0010#Gã;\u0013ù\u0002¿=ÜIô",
                "$\u0016øb/JÍ8ìÀ9îÄË\u000eÙ\u0012ù8\u001fgT»e´nd,§u#â\u0005µÏÖÍ«n©ÓiüªúàôÄû\u0018å6$6\u0007ÆÁÍ¾(ÍjT¬(ÝD\bDèãÇ§h¹NuYqK7\\Ú\u0017z°uJA×]O£&pÇ\u0013yL^5ôù¡Ï§¦DqvC0\u0000\u0003\u0007Ê®²Ó©\u000e\u0019hT<ó{µ\u001b[ù",
                "m6ð",
                " §øá~çò\u00039®æö\u0011 GqIì.¬\u00063íHkêX´×ÜöoóbXÔC5÷\u000emM\u0010÷´Lï³\u001a\u0005XØ\u0004Átã>#É¸\u0004ÙÜ7áÑ«©ÁÐk}Êãèõ¤ñù=\u0005îÚ½´Ëy^|o\u0014Þ3£Ë~øNk¸MÞTn#JÍ8t¡ ÏF\u0019i>zôEÃ£^»û,ðNñ\u001bMèÙ,\u0007|",
                "Ù\u000er·¸1NÊ\t±9\u0001¿Ñù>ÌÐU¶©NIª\u0000e¥Áé'õ\u001aU\u001bó±¤\tJ%fK\u0019",
                ":b@Ü¯à¥*E}\\ÆmËM\u0000u\u000eï¸­Hêòüúìªðc¾ÁA\u0005ì\u0017Zºc",
                "ãÊ\u000eäK,R\u0014®ÝÒÈÏ\tt(¡(Ñ ^\"ÆÐrt~vÂó3ô\u0013þ",
                "í\u0004Q¥AæÜtG:ÇmÀè²®ÿ\u001f",
                "ä\u0000é0\u0004Ùµ2",
                "»8«£loW°ý0z",
                "Éö\u0000Ç*,3~àt\"Ô'ö+\u001aó¼no\u001aéÎi~JKjöÝWGÅ\"\u001f³2­ÁJOöÑÉÖúõZ~:¦D",
                "N+¶\u001bä¸ý­\u001fÑ¶8\u000eü\u00076G@U·¦+x\u0011fÐÍ&­e\u0011\bïôi\u0011ÐÕ»\u0004`Ñ4G$ÍéDzÚKJÏU¼",
                "ÈðS¾EyÜ",
                "]°°Ý¤hu·w6#\bH÷/\u001bDÓíQÞ)2£\\]Ï¿Q§÷¹9ÈãÅq+ãr>6O<¨ýþ_&« ×Þáòü\u0016@b?þ Ì",
                "\u0002\u0012ÏEA=öøØ³Lá[d\\áãfélNä\u0010IÇ\u001b",
                "zãxÉ²Þ[6ú^W7Ø\u001a|<",
                "ºE\u001bb\u0014îÚ«)",
                "\u001862^\u0017¸m4E\u000f\u001b¼?ðä",
                "Oºôµ×S¢ ",
                "AØuû8É\u001f»gLs\u0011RÆ5¿^\u00017qS\u0007Ù?[8j8°¨?0-r\u0001\u0010lü7",
                "2\u001bê¿Ç¼fz^Ä\u0011«úÄ/EÝQÊ¤¶zü",
                "t\u0004BQ\u0017Uë1nn %E\u0019¨ÌÓ9.|9r³-Õ%,x°ÕÜ5JË¸ì@W",
                "Ù",
                "Æqü\u0018¥ñÁ¢¤¢\u0018â«Úò\u0011v\u0014\u0015r\u0013§\u000f5Ê¹±ñß§Gï\"\u0011Rx$è",
                "Ô[Bü/MwVãCî",
                "GE¼X\u0018|MÒµ8o·÷\u0004\u0005;{d\u0012TøLpÓlyÕsÛL'ýU¨¸F=Ñp!\u0013£í¸)ÄFâc\\m%ÐY®",
                "'",
                "Æöa@",
                "ºô",
                "Î°íâ\tBP$ø@\u0012`\u0001ôM*½",
                "ÜâæÀð3õ1ÿ7E°Ä%\u000eôNkzäýMë\u0013\u0013©2ópÄ",
                "\u0019Ñ1 7lW\u000f·® '\u00031 vñ",
                "\u0015f×êø\u001fag.ð",
                "\"5wZ¢E:Ð^dñ<c-h½¶",
                "",
                "Bó½#!AZÛðt_¸è\u001ft,ç_vC[¥ÞF)|iæì:Ö\u0001âÝ½þ¶{dL\u001fÑ\u0016=ºÐ\b?Ü\\áÁËh\u0007*Ø\"DÎ\"\u0002\u0012Ï}Ú#8\u0013y6Ó®ç!\u0003çy#",
                "\u001a;%¸\u0019çkND±F\t\u001fKt²N\u0014\u001fØ _úû\"S²jµR\u0011L0@Nr]áá´Ñn?±ík\tñ\u0017p×h=ãKº@ZÚZÂ_xÆ4nvNò,:ØÄá",
                "!\u001f1Ñ\u001a(O\u0014\bÄÁ¥r6cäCg·£\u000f·\bãâÍØTÆµÍ÷¸bÝ¯QAì}·»¥^+\\<ßíû",
                "lÄ\u0015^É6ÈHWv¬2ÀÔaPqxøÙ$· \u001b7Ìø",
                "/ùºá&{4",
                "ÿ@",
                "·\\|ü\u000fwã|C"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/57/5b39fcc607f73c268fec8ba78fef8a5a250e65",
                "size_bytes": 501,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/57/5b9b9d47d2e7dbcbb85dee38c0b6af43308e65",
                "size_bytes": 494,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/5e/c81c5382bca283308adec1dfdd99b532b5bd4e",
                "size_bytes": 2532,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 75,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001­XkoÛF\u0016ÝÏú\u0015wã\u000f¦RÔØÉ\u001aQ",
                "Çv\u001f\u0004¢\b\u0002bD$Ö\u0014åqÔ ÿ}Ï½Ãd¹I±kÀ¶4û~;óÄÌéxò§ÿ: ß[S¦mzñ:3yAi¹Î6¤,¥Y½mj­ëoEÏ½\u0003ºHmkZÇtN±¥8X%ñ_:\"­òd3 J£DSf",
                "ò",
                "ÙRÛ^oNz\u001fPù%q\u0018\u0017É\"½SV9¸\u0015:·rdë?iJOG#YÇ",
                "\u0005\u0013¬",
                "ÇÇ `ãe",
                "ø",
                "9\u0011oª\u0013#c",
                "xþü9]½~õ^¼xá(\u0005dÒÑxýÙZ%\t¾ÏÝòÂä­Ä\u0010+1wØL\u0014t\b7=!;ºè\bJ|gn\u0015e¹\u000eØ\u0010\u0004ÍÅ\"²yiT[§³§/óë\u001b",
                "+:`",
                "X»\u0001ÕJ`Iäê",
                "ç­«Ìè«× à\u001be­ÖÒJÃg",
                "1NÙëWçÁì÷ÙõÅUpúîô×ËÓ\u0017°Ìu^jÇ0ÓÂ{t~ñòæç\u0013q°ÝØB¯·",
                "nË0z2Å¼+¾ÿ¨ßÓBÁR\u0012@¾ÎsØ\t¡¥÷3¡½¨ÿ¦ò4N4Üf\u00132(5\u0005Íõ\u0016Ï!}Ö_À\u0003éAE~RÕµ",
                "\u0017\"NlR'\u0004Ls¦pEð",
                "\\Ü\tSö Hë",
                "\u0006·²\u0015\u001aIoRý)ÓaÁ.:E%\u000e,Ir©k",
                "èÒÊøB~ÅXv|ñÿ0R¯7;½zsy\u0011¼=½æ\u0018~ù<[  U",
                "ÑÙ9ýY\"ËM¿w~ñÓéÍåuÀ·~½¾9çK#ÿ\bWFþ\bAFcÄâ¥²q\bS+\u000e=R\u001fM",
                "Q®:Õ¹*ØpqÄ\u0005\"D",
                "\u0010\u0013Zìf\u001a\u0019\u0017%^ KA(×§ôù",
                "(^¯rS\u0014(-ÎâY¢6s\u0015ÞMâå",
                "µ¤\u0017$Ê\u0016\u0001¯\u0007\\¯ \u0018îõPa(¨ØêàN}Ô>%göàDHcÒ`m\u0007ÄÈêõôÐ¢(",
                "\u000eH­Q¨2ÒÓ{j÷]8?zôèg§¶¤êBçjÃêäÚ²PVUR3",
                "\u001f$ã",
                "øþ8vô9Îs]yJ¯",
                "",
                "%GoÊyQkD âÊñBÅ\\á[½\u0011¾ªnGOX Ù\u0012SêzãXÝÍ÷Íµ\u000fN\u000e4À²\u0015a)\u0012¹ðºáö¸k~úPí\u0011DN\u0006ö`\u0019\\áiæ'qj3\u0015jo´åµæÚ_3\u001bN#¹=bÐwâ@±ÚÇ4ss«\u0011ïYãuzÌ\u0011",
                "ÞÄ}Ìbüç-ÑÏ",
                ")Ø:¹Ç\u0003©ëÃ¯sY¦Þ?àö ;uJ_¬þ!ëãußRkÈZ/\u0012cr3û»®ÝýdHMl»\u001a#jg@\u001aHÝ»U\\h\u0004=ö%\u00038¼Å%;f¯",
                "£\u0002µïþy",
                "\u0007÷QeÇ5«OÀâ\\/T\u0014\\m8}\u001búÿ£W",
                "Î\u0001f\u0019º",
                "ÒØ)²P",
                "R¸!Í?\"Í)\u0004¨¹åd÷´¿ô\u0007\u000f¶ £áxDkëDå[A¢Ó½¹Ð\u001f",
                "õ¡ÈÑÚ\u0012ljD\u001b×ôBvÆc°Ú\u0015$\u0013-È\u0012\u0003\u0001tjÊåJ`HC--üYêíBÉ",
                "pù",
                "4Ä¸µsÞ\u000fkÁO>ÐãiCÆ%\u0015JI?jÀH®þÇC \u0019zsvÅÜ×Ê3ø\u001fu^\u001a\u0001\\¹Ôd\u0016õÉ",
                "É!ÏÑ\u001brKÞðÉÓãgL?<udáZJ7\u0004÷DÓÇÕ®\u000f\u001bo2Í\u0003\u0012ãã*Ñ\u001f(J¸^S\u0012ãVµYsÝ\"Ì¹",
                "U$\u0016¹q¬",
                "o ¸´·µÿLråß\u0002i3Lfþ\u0007ð\u0002ê",
                "Y7­A\u0017\"Ý.À«4j)ô\u0000M\\æ¿Ö\u001b\u000evaJÕ",
                "\u000e®éøô\u001b\u00176&{Bïóú2¨À×éG´\u00105OøØ~Æ5ôâÈè´%1f\u0003ðyóÃ!½½xwñöún,|\u000f 0>'$\u0006 (Îa\u001fd\u0015",
                "\u0005wñJ;@Æît¯k\\",
                "@%!åHØ\u0000EDÞ$o|ÞFnU]ý4×ôo",
                "\u0007m!fv; ¯",
                "£Q",
                "ØÌ­ÓËÑzá\u0017»RÙ¶5}Yê\u001aÈ©sZ\u00007\u0003\u000f# \u0017\u0018(0Q\u0010|[¨[gE£JTÀÿGzÓ\u001f\u0018\u001bbqò#]êâkA ¸È|å7bê¹B!¥w*)õ\u0005cR ÕýÁK\u000e»r B\u001fg;_Äj\u0002\u001f\u0006¢V':Äb_Îµ\u001b;Æª4ãWE¿e¼\u0004ñ×PÏ%\u0010ÝÅ\u0018d\u0014\u00133ºQxßnMMãq²\"+Î¡\u0001Z¦¬\u0000:",
                "ÀòKa\bÚMWÜmWF7\u001b",
                "DUpÃÊ",
                "ù½},Ú Û1«\u0007:\u0005\u0000É$_»¡Qå¬0ÕÐ´3¬4rî°\u0011g¸­¿Ã­\u00198Dª\t¿È\u0001\u0018.7$\u0015L£(\u0001$ðZ½ºÉíry|\u0017Àô3Ñ",
                "ÝVÒÓ¤VòWpv\u0015|\to÷½û¥ê\u0004æ\u0000Dáu¨Ñ¶\\ë$\u0000áÃ\u0016%£÷\"ÝðLjîYé",
                "C\u0015\\år\u0013\u0004S =%TZ±Hb¤¢ÃbUFwÒ¤\u000fÅ",
                "Õ+ÃøhruiîZd'Ûõhx:æ\u0013k\u0017v\u00075^Ù3T´Ètkp\b°\u0003³§#ÿ³µTc'ûtwL\u0001",
                "ÞOÐá«mzc\u000eµ\u0016",
                "u@¿Ü¬L\u0017é«'\u0001TÈH[TáH\u0014®|¾¿¸ô\u0011Î¨\b<TUçø(0èÿ\u000fz¼}Øß|øtÓþØ½\"\u0004`çX.xÊÁAñx×«ËÆpÈ'î]\b>â¯pa³=Á÷É¤Ù¯Õ6\u001bïñÜX,¿|",
                "fÀ\u001aIo\u001búÖqL{\u000f­ÐÂßo¥\u0015õ",
                "5ª!\u000eÀ",
                "WÈ¯OøõÄôh~'>§\tª\"c\u0004Á",
                "üöÄ«\u0013F\u0010Í*",
                "Ä\\ãÿ\u0006\u0007oI±ícÌ^:\u000e´ídÂ$ëÊ\u0001ûV\u000e°\u000f+\u0017®",
                "øªm-)\u0006«={Æ\u0019õ",
                "\u0006w~á\u0016\u0001y\u0010GÆ\u000fE«ýÞ",
                "÷f÷&ÙjÈò7\u0011^é-\bR¥<ù\u001b8,\u0007lòP»r\u0000",
                "â^$ðx0=\u001aµ¥î",
                " ¸Õº2WÁ@xMÕøÇSÆY\u0011B",
                "~cwÕ´¢ÆV¸ð0\u0002ä\u0014áÝ®t-²qì\u001a·;Ç\u0017ÌßÑ6<k02«\u0005d`¨\u0004a?âý@Ü\u0012y\u0001§~Uá¹Ñç¶\\Ñ40\u0013òä\u000ej¼\u0003ÔÆ¥R.V*ÑZég\u001aTq$PóUèûK]TRÆ0Oõ\u001a ",
                "%§+ÈP\u0006,yï\u0001¡ç\u0005á\u0017_l1òLZWcêº3\u0007qæsçz^.PÝE#_ÆOU\u0017Û\u0017¨ê\u0005ÏJã\u0001",
                "Z:O×o¤l\u0011'ÀlhxåB}m]O+Å*^ hfám5\u001f",
                "0­­I\u0002Ö·e4RÈw",
                "'/",
                "y\"¼È*L8-×Á ÂÊx\u0006c·°x7F|ìNß±þû:Z>À3[ÖF¨d\u0011ªjx[¸Uà¥\u0012Ü½¶/¾,O_",
                "páÛ",
                "_Â",
                "N`Àò_|zß\b"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/60/6ab8e7f7fa408f1597ef120713447b2f9f043f",
                "size_bytes": 9762,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/61/432bc8c17a642b9a09d11d9fa470104d8dfe20",
                "size_bytes": 158,
                "status": "read_error",
                "encoding": "Windows-1252",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/65/7a6419a20a27e101d7dcda234f23bdf2283005",
                "size_bytes": 2083,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/67/23e46589718f81ea4ca507f42fc6c080ad27bb",
                "size_bytes": 1628,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/73/c4b0449a6981d36adb2a16dd2ff835ec669494",
                "size_bytes": 7459,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/79/b2c724219bf218420857db784b3e182fee56eb",
                "size_bytes": 164,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 10,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001UOI\u000eÂ0",
                "äW\u000fäÀ\u0001qBü\u0007Diâ\u0016",
                "²à8*ý=M¡R{±<£ñ¸{¥\u000eNçËáî õ½",
                "OO",
                "ÂTóëö£",
                ";¥TÃ\u0015¥¨ó´`ÈÓ`\u0003Î,ã»\u0012cÀ(EËGT",
                "i¾Õf",
                "E\u0012cVkr)ö4lLèpK",
                "L~çs[ìÙ\u0014w\u0019­Q\u0011+®ÕÐú?oïÂÕIe\u0004Ç8«üQe[",
                "~\u0001ì/[k"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/7c/f0c4d7e18dd5aeea366581f7015125e64153b6",
                "size_bytes": 43,
                "status": "read_error",
                "encoding": "cp1252",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/7c/fcfcc69de5f56d031bfc15012dce59e9822193",
                "size_bytes": 277,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/84/f24d5476dfb7862446f87dfee22f51646ab3bb",
                "size_bytes": 2662,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/87/621eba5659a4d6991b0082715f3de87a93298a",
                "size_bytes": 3663,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 102,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001µXkL\u001bY¾eí26~!<B(\bIÇ\u0010èð\bIÈð0y\u0011¦p",
                "¸",
                "» Øeç\u000eÌÖ£",
                "i\u0012iv;",
                "¥7lk¤¡W-5-fù\u0019­VZ:ý'¿V®6#ÜÕhÅj¢å\u001fêÌJ£î\u001f½çÞ²!éÌüØ½oÝºsNsÏ9ß½ÓÑø4ßÛ}¼\u0007½(//CPÞ±mÎ",
                "©Eè\u000fä¥PÌùÆg\u0010ú\u0010\tH`.!ÌÐ§\u0001\u001bèÓû`À¬`Ä&ÅfÁ-\u0001Ã¸«@dû9^¹Ý.´\u0002lÀ\u00140\u0007,GY½G?°¶ª°bûùòZÁm\u0001{3\u0012,GAbRx\"K°c÷\u0011+à_)\u0007Ü=\u0006ÁQ~Ì`à¬C¸JpA]-¸¡Þ#T@]#xJ:£vi\"2ÕéôJk",
                "\u0012÷ ",
                "#\u0017p8P·¡¯\u0015Û\u001aAcØ1ä\u0018\u001bÒ3LÀ¹cUÙkWÝ(®úËüm¯¥ô·\u0005J3è´±\u0011Í0ÞªMò)cáß\"\u0014Ùúþûï7Æ\"ÈÐÄ|Ï°oÐ®\u0017â)9Ì+sJRñ\u00119ÑÈ¼\u0004]©PHRT4:Ç\u001fº",
                "ãÞù\u0013ùU×D,GäY¾}çúP<\u0015",
                "ór<ÉOK;µó#óÝùµ~YºBIà!a",
                "Ç|8",
                "\t-e·$@}¾3Ïi ¯aôGÝ~\u001bý\u001a«Dd)ßu´×\u0002µ\u0011þ/~",
                "õhJ",
                "õ¡|+",
                "\u001ae&Éý=¬ÌúÙ)Ð^NÂC´\"´ÝãgMÐ×¦È©7!?Ó\u000e½¡ÝPa¿È¦)®0szdáMÂ6ú\u0019}\u001füL0`e³ß û&w'B~c\t\u0005ûÎÕäxEÉ",
                "ÇË3T~Dk3©",
                "²¶l¹²\u0006Ü8ÊÍ·Û+|½\u0019ðú?fT¿\u0002©¬Tª7T",
                "H;ù.©K$¨xùkA\u001feú¼v\u0018,R\u0005Ýç¿7\bm²W§\\BÏó2½ñWD(¿©H\u0017ä\u0011ìíÛÔüÛëU;O('ßVIæ&'u}õ==tpÆ^½\u0007",
                "ÓÏ",
                "%^\u0002E¶NÞm",
                "\bwÚH~,ò[ÛAÏ",
                "«\u0018\u0015ÃAä·\b.Âm",
                "bäîR¢ÉÝc%òùËJ=",
                "",
                "üe-Èëï:'É\u0012\u0016Â¼%æx\u0011cqÇR\u0002K$'IÐ\u0010óaã=ñÔ16K9}ÿ,&~;âe4NÃxDNb\u0013mnÍ¬ÜNXÒ8E|/\u0019'ob\u0012#4",
                "(\u0012&_>û\u0013ÏïÎýç|²_'¶",
                "",
                "\bßÿ",
                "BÞr­Z¸â\u001f\u001b\u000e",
                "ï\b\u0013¾ËÁ·\u0007.\u000e",
                "ú4{Æ±`H",
                "Ý4#pÖlÂÀå«£¾àøÀO3È\tFd%!`",
                "BfHDH¬5ÓL4",
                "Ç\u0019r8",
                "ÓÌ¢KH\t¨tözmu\u0006K·S",
                "Ól\u00105Åd$.\u0007cÆÏãf\u0015ch$",
                "K\u0010¼%ÁdÐ_P!C¢Ù\u0014¤JQ4¬Ô¸\u00191,\u0005£oÅSIKbA2ª@",
                "CüvÑFÆû\u0002\u00137#",
                "u(0",
                "\u000f¥b`",
                "%0<p",
                "\u0002vgà*\u0016CÉHHT\u0002ç¤\u0018$v°`28¢\u0004\u0014",
                "",
                "Pýt$æ4Gp6obÊ\u0007\u001f\u0000>d\u0003(¿(F´5}ikÊ9+7ÜuK5\u0019×éô",
                "Åõh4ká×õ",
                "\u0017TçÁ",
                "wðyEÕ£[Ôê7\u000fªÕÇ³\u0015'ÒÖ+<Û",
                "¶-õKwÔ¦£Ë?yæW+ô¥",
                "óAoÖRsÖüºë7½\u001fõ.6}2ý©ô±ô±w)¢6\u001f{Ò¦6û²õ#ªsä>³º\u001fLf­",
                "úäc\u001f",
                "û¤ëÓÞê]júíô?KIy#jkÿJÚz9»,[Eu^ÑWý(kmU",
                "÷¶hSùcÿÚüoþåÐJ÷³zõÂ»êÐ»Ù>QåEÕ9­O¿µîÝpÕ.¼õIÅ§µ\u001f×®5uªMËmÙ¦3jÃ\u0015·Ú0¨ºî{6þ²Ð÷Ø?«òÑÉÅ*µò`ÖùFú|ÎR±È|\u0010ÈZÖ+«",
                "|xrAY",
                "ZªÉVvÝãrýÞ;÷~åj\u0016Î«\\",
                "<·8ä®zúÀ¾ælQ-:ùñdÖÙ>¿±ïà/F\u001fÔªl}ÎV¾ò\u0002ìB\u0004O\u0014",
                "ñ/â;/2Ðû!diØ7?a÷Áøx1·\u0016HÙ÷ë¶c\u001bdE4^Ì¬Ûswb±)ÈÍz\u0011ØWÓv ÁÔm,DF)á`þ«8\u0014ãåø+³;ê2SÅÜû×¢d?SL6Hfñ\u001bv~§ßÐÐT1;\u0001Ö<",
                "qÚX²ó\u001bw®\u0011¬êm\u0004Ï\u0003þß]æ;xD°¬l",
                "0Î2ús)bÉ²ùSCXÊGãÄÜ¬\u0018:b»\u0012îÐ\u0001d|úÇ\u0000éø\u0019",
                "\u0015Ã5\t",
                "zÌî\u0018£auþØKðÑWÃüö|~:äg\u0001F*7ÅÔÇÏ\tQæùØJ¸ÐÁëHd\bX¯§\u0007\b|",
                "Ð*OÅ;LÉhÌðü`÷@\u0012n&üw(r.í·$\u0005ÿ^$y¿|eì.\u0015oÈÓÐU\u0001\u0018BVýÛAÊü°ÂZ*ò6°-Ì¢©É[É",
                "ÒX9",
                "i¦\u0004\u0000à¤f¢\\´²·ÅhJ¢40][TBqHw³©xJ¡jf]tHayÙµ²má5«ïnHOË5\táX\u0016C·4+å\u0012î¼&­(;¨\u0013ó\u0010uQ}\u0006·ù4äã4FÂ] BÜæ\u0000ÜBdª~µAðq\u0018¼Læÿ\u0007Ti´aq«\u0016hÇ¾l:¶á¬Ü2T<[fd¯~¿ÿ~ÿµ5®ÛÝ\u0019Ï¥g\u0017×F\u0003êh séz¦âÆª=ø¼bo¦ñzæÆÍµ\u001b1õF,s]ÎÈñLC\"[q;c¿ý+Ï¸Æ3Âõ5!¤",
                "¡Ìx8ãV¹çMkÝ_6v/_Ì6ög¸½ë®êÇÎ\u000fk®VÕÕiëÏºÎÞ3­ÕíKÒÒµãè*×szîÙÿ¼nó¼@¬ÉCG{ßZ",
                "Ê8¯r'¾æjr{«W¹úU®aÝYùÝ\u0015æ}«\u0010\\óÁ`ÃàèéeC\u0007OO4\u000fñÆ/x\u0013´C0V,\u0016hÑÐH´\u0003lF@'3SÅðI?\u0000~Á",
                "ß0EæÒâ/",
                "6\u0001\u0012Yæ;õ}§ðÉR~ïÝ.ò\u0014øh<tì7ØKq>\u0011\u0005»wlþ\u0003ÐÙ<Eª0T¤òÙnZ¾èÿÌëIç^¨ MÒ/µ×¨±\u0004hh\\\u0001cä·",
                "\u0005H",
                "\u000ev¾\u000fÜù}@xë®\u0007aà&\u000505l\u0001bngz8çt§Ï?w7.\u001a\u0017'Xõ¨î«éÏmM­Y[{mÇMQ\bþÅRÔÚCèÚÖ`",
                "\u0002",
                "\u0001¯¨½IhN°îØÞýÅ^Ã½ß4",
                "@u\u001bn³E^ÅF3ôõ\u0014µ~",
                "\u00118Ù<E$¡Åo.\u0004i°u~_Á",
                "b5Hhäãw 2F¸\u000fVn®ê[¨0I\"y",
                "dûñix\u001bó²ºî©³ÛÀ\u0005C\u0010geøëÖ°\u0000,\u0004ktj,£Sé¢/]¸1ôGV",
                "Ç¦áÌ\u001bÖq\u001b\u0011ºlÁX\u0005§%\"\u0006yÁÄÛðW\u0002PQ»Ò¾Í\u0001f\u0003Ûé­u{ÝÂÑåº\u0015Eµ_Jûv¾åzOª½çùÔÑë\u0006\u001f=",
                "[ô-YõteB³éËë`äö¬íH=ò\u001a#÷\u0002ëm#\u0011ù³ð\u000f9yþ3¢H¯\u0013â2¤\u0002",
                "\u0001JQ:\"\tØºw\u0011=",
                "Ì~ô¤|¥[\u0001~¯\u0011÷á³¤â¡Ú¹Ù÷\u00146;",
                "RFy\u0005¾\u0005SF¦\u0013\u001f¨\u0007JÈ¹*ÓDM=Ë#+!Õ~1=±no^ìÉÚ\u000feLtM\u0010W*\"~\u001a£øéeä$=ý»n*JBÅ6ú0N\u00157ö«pS3*d|¸k\u0000®",
                "âýGã\u0013\"\t\u0017»",
                "¿GóÈM6MúÈy×oèS¡\brÏ2\u0014ÙïZ\u0004¯\u0005<[â=ßø\u0006û·×#&@9\u0010mÁ\u0015÷òÌ;Q\u000eE/æ\u00013E/ð,A/¦ù3W£â",
                "Á\t¥)Ìðâ",
                "1\u0012\u0015§£Òa",
                "|\u000eáÃ<¾è%\u0016",
                "ãÉ$tuEþ\u001blES÷|Þ!ÀÎ\u0015³{\u001fï-Ó3º!\u0012ÖXrÂÒ¬$­&ãr$¤9Q8Ê\u0005É ",
                "3ÎJI%ï¸\u0003\u0014 èM\u0018n",
                "¶×¢Ù©A",
                "1ÃÇ1",
                "\u0015m\u0005ièO\u0001¼ì¡\u0014Æp\u0000ÓéÚ|¤0>\u0006Ô@\u0019®ÇïÂ_Y\u0007UáÄõ»½9ÎñÜé~p8ëlL_¯ÜóøÌÃ3ÙÊýaµ²5=ú_6×zõµj¯Zí]:´<­î½gËÙö¨¶\u0003K¶¬­{Ã^±Å±¦¶",
                "çYãjU®v«Ïµ",
                "ùsûk<ë~ÿÔýS/\u0010cj£¹öÀ¢¸(d",
                "Þ5®UåZ¿Û2Â\\?ßW;p",
                "}~Ü3Øb|jw",
                "6\u001a6 í5l\u0012Pâ­C;¹\u0019 8j\u0012O@?ubÍ2",
                "I*p©q¡¢,KQE3O§ff$¬(6#.äÎScIM",
                "Hmß!Tþ0\\»!ìJs\u000fûF\u0006ü£\u0013Ar¿0á\u001föa²ÏñÛ¤*&Oþ0¨D\u0005ªâÏ\u0010uw=cr§bñp**Á·`$1¥",
                "jølù\u0003ªø\u001al[æ*fÿÍ\u0005\u0001ØáNË9]p <\u0002ÙÔdûåèÏG×X8Õ.´,Zj{WÙ¾",
                "[¦÷W©lÕðÂ¹ÅÉ¥;«lïFCS­ûµfÊÎ®²\u0003[5ÈéIÛr=\u0019ä\u0006j®´}£ÂvnôôeF®ý\tíg<ß2{ îáo<eLç75&Æû?\u000e\u000fÓöç-Ñ8Ç/úó¾@\u0006f?!k÷­+B¦ìÂ*{1×Ðü{¶î;8§á¯Leò³+î\u0015cÆ6¼jòåöíÿ½©",
                "ËwR8ýD|\u0002\u0014\u0006VÙÁ<",
                "-\u0013PÿV9\u0002êùû\u0001ÇÀiôùi×\u0010ìòrº",
                "¬¤}¨|°Ïø´¯\u0012Ú_\u000f5\u001a¿h4Aû\u0001D\"»ä"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/8d/8950d5e0c839d7a56aa1a7e0b464d24e1a0ed9",
                "size_bytes": 3005,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/92/4cb56a8536d571b6e921a614bed444a6cb812d",
                "size_bytes": 123,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/92/d50e9d0a85149df6f6f4e08ba9570d84c2faee",
                "size_bytes": 295,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/9a/6e3a4a8b8ee57ef69d4a7e24267133d00733b6",
                "size_bytes": 1372,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/9d/b57ec4779b52c8d0efc01df31a4d7f6af95698",
                "size_bytes": 189,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/9f/5c44043e0aee23d27bef458f203ac5534419e7",
                "size_bytes": 1622,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/a2/f57f188a827f1f8157c973e85399073c4ee24c",
                "size_bytes": 157,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/a9/c7e4fb6e0357f43e93d57c7313f53fd9f310ff",
                "size_bytes": 89,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/aa/03c9c66b89f9f4298996fb755a5305b3695a59",
                "size_bytes": 1574,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/aa/42454b9d76d7daec3ee398063bfa54265865ae",
                "size_bytes": 89,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ab/d5a24a71553b2f7fd90c0e9534d1a5ca194a39",
                "size_bytes": 302,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ad/b8232f3c61666ce2c8d3bb9b3c90e26ef221f4",
                "size_bytes": 4708,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ad/c27e00b5d6ea56cf4a044cad3b09e42ce6ee1a",
                "size_bytes": 318,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ae/98652efa584f78d20ff3609876fb0f6ccf2d6c",
                "size_bytes": 1188,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/af/67baef2cb2d4a0a2dabe1661f23cb187074909",
                "size_bytes": 3868,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/b5/9b50ee80457a24b00a718ce041aa1b03cb187d",
                "size_bytes": 1445,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/b6/daceba37172873707bd55f99c5d4f6235c928a",
                "size_bytes": 301,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/b7/c166da9c274e2f33aec01afe2c0aadb5382b8e",
                "size_bytes": 253,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/b8/39e4d9da8c5fb9fb1b3bfe1628522ed9e2a326",
                "size_bytes": 1715,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/b9/7bac89b54eabfb13b4cc540332f2f728c2539d",
                "size_bytes": 1366,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/bd/f09b69f4a0a2a4927e62e79b82a499d3dee30e",
                "size_bytes": 221,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 5,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001]AÂ0\u0010",
                "=÷W<Ú¸\u0007÷´à¡`(",
                "[W\u0014\u0017<IÚ»¦\tTðßoÂ²:§ùÞ÷¦éMõëzV]ûò-5±Vö]Ñ aÔPÚ\u001aç!Â{\t9zem/Q\u0005þ\u0018ùyÜ-Þ2Éóü@Ö\u0011Óà\u0019þ`",
                "³jzBr3Ì5}Ç¶U Sª\u0016»\u00136É>_DM\u0002µT\u0003t8\u0002![¯nèýGy~ßU\u000f\"c{yËÓQl\u001fØ ÞËéÉ",
                "s#÷w[RqëTZµ¸|~Ã?ÕT:å&4wcº_c®l»"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/c6/c615b4c114af8ab7be388ec973a4f0af9fe67e",
                "size_bytes": 179,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ca/fa6365d17d5704d944121a42af797ee5111959",
                "size_bytes": 89,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/cc/d90d853c1fbd4fda8eccefd3e6054bb273943c",
                "size_bytes": 123,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/d0/0ee014c4ceb0f35b78a1b33b906646490a2b82",
                "size_bytes": 2205,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 72,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001V]l\u0013Ù\u0015¾c{ìòã8ÁId\b\u0006",
                "Y\u0002\"Þd©q\u0012\u0012\u0012ÖÛl\u00130ñØ",
                "kÏ;cD\\UÊ#}ê.Ò\u0016\u001aU\"¼-«Õ\u0016iû°­Vjv³RU©ÒI$¢Ù¨Rµ¼ õ6H­ÚöÜ\u00193ü´j¯ìû{î9çsçûîBAY`",
                "\u001f",
                "BÛ¡\u001fAYëÏù¯\u0010ú",
                "ìâªu¶G¡ó\u0001â\u0010GE2[\u0017v­\u001b»9\u0017öpnLs",
                "ìåhìã¨k",
                "çíD¸óAíÏS\u0003Ì\u0013¢jZ\u001aÿ\u0018¡'?nþGONÿ©ò«ÒÍV\u0004,×\u000fZ7ü·÷ý\u000fÐ",
                "e/pTÚÓ8×Q÷±Ú",
                "æ¤Yf\u000e\u0016{E¦ç<öJÊk÷vÚ^Ä¹gÛ8\u000fGxd¯CÙ±{½È±nFË^±ZÐåÔ\u0010|~gi«ö:½¬{ësXxµ·>Î¦ÕNËy\u000f23ÛojfH-;u4¾ìC/J;%_à\u0011Üàð$ü²L/½0ìrÈü'=þ´óÅ?G\u0007Og¹\u0006®áu\u0017ç",
                "võRXó¾´æ³Ö",
                "ùö§ý©ÈË>4¢£.;r,JûûÐ@ ü\u0011ÈùO²y¶X\u0016U",
                "ó*\u0015Y¾\u0014¶ÄÃtYæYEÎò¬Pæ³NV\u0014°(H¢¬\u0007ý\"É",
                "QVa\u0005EfÅ\u0002+¯ý¦(b",
                "\u0015Õ\u0012Èå$5Ð*ð2_\u0010Õ¢Àª,Á¬",
                "³JA\u0011xVÙ\u0002Æá_Â\u0012Ù¯Ú\u001bØ\u0003g\u000e\u000fÄüå*1eºd:X\tØr±X",
                "¯or2\u0018p¨\u0004¾iOÈÌ\u0013rõaÎj%qºÒ9©à\"9Iå1æ\u0017Ù¼\u0019¬\u0012g\u0007\u0002\u0006",
                "\u000eÈá&K.\u0019LAÕ\u0012/Gò²áV%Ùp$67\u001b4\b\u000e",
                "7è",
                "qÚ Õ+|I\u00045",
                "É`²eÌ",
                "\"\u001b",
                "_,\u0015$­5B\u001a¯ò\u0019+à¢b\u0004är1S",
                "\u0011$\u0003;\u0017F¨T5EÍhX,)FS'#røLQa+$$\u0019Ñbº±Bk­*\u00174I",
                "@,ØbNÅç/\\Tö|r~\\\u0011ÊEP¦Î'~À",
                "bæÏ÷\u001a¤P?-\u0016%Y:¤Á5×D",
                "Kê¼",
                "yË\\¬´hôf¬0bËAûÂd",
                "\u0017\u0006³`¼\u0005þê¿ ZBÏöëAv¥k%ôáî\u001fÙðÄ·ZÛßûqu×áõÖ#KS[öÛgo]¡VN¬NT#ß[:÷ÌvuÜÎßÊÿbánn9·òöÇá_¶Ýo»÷ÎHuß±ÏBÕ}\u0013ëÝëí§f",
                "#·\u0007o",
                "ÞáWZV¦ÖÃC\u000fªáá¥³íÝÕö#\u000fÞ¨¶¿\t2ÑÎ»Ì2³Òó¹ë·Ì¯j4¡{ÚÀFçkw£ËÑQ½wì«Ôïf¿­vLëö§^Ä´¾Ç¯ûvmî",
                "^",
                "ºÃß\u0019®2ì«g1æáöëý#úOVûOêû¿«û\u0013\u001bSÝºg÷6\u0000\t¤²",
                "ÁQ\u0013ÅOY(nÏ£\u0005À·¹ú¨Ïàã«îvbî+\u00101ÕPWQï",
                "«õdÀÚ\u0003µ~¶\u0003¬Õ9sÏÕñ;õ",
                "æ<#.\u0016å©4*ÃRXv;öÒi",
                "ØÇvAíK»\u0001",
                "¼;(4\u0007Üi¹:\"ÎÕñs®bi*í\u0006¥e\u0003CÛí½;m",
                "ü~±¤=¶=NÓ×çj°W\u0000\u000fé>´Ç\u0019½Î\u0017õ äCü>`",
                "¯ãtþ´àêÿ\u0012",
                "x\u0007ÈÞ7OYm{Í¶QÓìsh\u000e¤}ÿf_Âgj6GåÐ»\u0007å¨`ùo`ÃFøE\u0000¼ëe±p]\u0004Tg",
                "«¢\u0006 ¿çb¬(Ý\u0010qSÊrÖÂ}F1'",
                " AÛÄhAZûT&Ã$Vø\\ÔD",
                "ÀÈ]\u00030\u0016\u0004äMl-\u0015¡\u0000àY\u001baY\u0013À\u001a\u0001\bJ±ÄkÒÉ",
                "I^¸\"\u0002\u0015\u0014@",
                "X\u0005[clB\u0005Db¯Á¬ÃUö",
                "ÏªA\u0000\u0004/H\u0015B2%,^à8@M1ÿt%v\u0006:²ÆÜ\u0004~aÇjöû­£á~ ò\u0004\u0004k\"IÅÙ/ï\u0001Iíø/\u00136ÓÖî=o/ÀØ´YàDÐoiÝ\u0003TãÉI\u0005±ÌÆsõ(`±¤`míSB9)\u001fg'!Æ*þ¬ÉGbö\u0016M",
                "Ð|\u0001¸Tä¶ã]¤BU8BûfrpÄL",
                "^»CÒXe¨v \t!\u000f\u0010øóf\u0014kÂ$2õL\u0010",
                "Æq¶<",
                "Êí]7\u0004±dåÝÂöÂÙ8Ðd´\u0001A\u000em\u000eª\u0005\u0017\u0013Ü1¼Vþ",
                "Ú¼k\u0006\u0017µ",
                "d\u000fV]T",
                "¯ªeEM0Â©dzb:y&IÎLÍ$\u0013)£y<J$ÏÌLïÌ$Î:s!=^aT`FBè¿È¿KÜûlÐ WÁFÃ\u00049\u0006T<À\u0018ÍV",
                "2õ\u0014\u001b",
                "®3äö\u001aÁ",
                "y",
                "h5j¬Ýls$ªFÐÉ©à·\u0006xp\u0010#RÞ Dà¸Í°¸",
                ">bÞ\u0017ã2\u0002K$Új\u0010",
                "(ÀÍÙ]õ",
                "ØjêÓ¾Ç\u0006Ý\u001fßð¼ñÔÕCG",
                "wí¹;úóÑG]Gª]GÖ»^×è\u001fz¶-zøËÂ£ËW«¯>",
                "¾»Ùº",
                "Øèhª2o6¬to1!½ùÈ\u0007Ïâ«",
                "ÕK:wQ¿TÐ/\u0016õFyQé¢ñ­½[mûà·Ù¹w3ºÿ/\u0001oÔ3ø,ÂÑÛ=ï÷<j\u0019¬¶",
                "~8µÞ2rÓ»Éî×ÝDkã±",
                "æøfSÛÍÐß\u001f\u0007Z~:úÑmä¢#¦ÁÄêÕN½qjûþ#îb»ø¹´ÕÔúÏ­@dGh|õíÕ¤ÞøÖ\u001fÔ¯+¿¯<d~H$Ò ã\u001fêw *Ëc§N /¢",
                "h¾<\u0011\u0019ïv¯\u0005»\u0007Ýk\u0007C¤?Ò5Þáþª>y´Á»©´Éã\u0006¯\u0003\u001323B\u0017\u0012\\\"s.=Á]HMÌ`¢\u0015\u000fê ©úHÅ$â>Â{HßÌ\u00173ZT²åø&",
                "9ò|TãP=uS\u0014õ-",
                "Bß ÿS\u0006µ´/",
                "6Û¢:",
                "CàuÔlÕÝ:jû«¥º·'©A*bêþ7'4ß"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/d0/bb3eebe50cc9f81158e72eef833d1e15cefa9c",
                "size_bytes": 10667,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/d1/304ef03b47e01cd9a856e48ecb586c9806be0b",
                "size_bytes": 89,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/d3/61c922671729bcd27cce13afc9177012f8fb1a",
                "size_bytes": 1922,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/d3/f0b67c520e52250eec2abe3ea55c1ecabaeb22",
                "size_bytes": 2549,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/d7/964ed2f2291e9c381944d081539c73ea496a80",
                "size_bytes": 7934,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/df/58174e151a7fb7017a31d46ac86c24c5f2c16a",
                "size_bytes": 9084,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391",
                "size_bytes": 15,
                "status": "read_error",
                "encoding": "cp1252",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/e8/f6e5f0c585b700bcd7dea74b5e5cd694ecdb08",
                "size_bytes": 6499,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ea/6d219145c0ec5f1817b75d7beb93754479871e",
                "size_bytes": 1685,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/fb/5d4bd06403d55420848b80d01cc9d6d6d9edb8",
                "size_bytes": 10259,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/fe/0464963ebfa2233cc6bed59f93585a8a7affb9",
                "size_bytes": 2123,
                "status": "ok",
                "encoding": "latin-1",
                "language": "text",
                "line_count": 58,
                "dependencias": null
            },
            "content_lines": [
                "x\u0001VMl\u001bÇ\u0015",
                "þ,¹\")R¢IK´ei$ËµeKL\u0014[%KIhIþmYá[©!VäÚ\\R³ËØb.:ª½$1Z5",
                "XE/\u000e\u0010´.\u0010 >ôà4\u0001\u0002\u0005JF\u0002Ll\"E\u0002¾¹\u000fE{hß,w©õOv\u0001¾ùyo¾÷³Ãïíb®°",
                "\u001fCÛ­­",
                "\u0004Ï·{\u001fgÙ",
                "#[ÝlÃäc$ Áv",
                "Q>Ú©]\u001f",
                "Ô!Ø©SpPNpRÀQ·`[æ\u0005×",
                "D[\u00047HOÖ6À?fP3ÒÔ§\b=þ)L³ï~uæ¯åÏÞÖv!âÚxÜ0:à·ý=ðÿ1·",
                "Ápú`?ê\u00181ö0gúsux\bPLÌÍ;MMÜeÎvÆ>$8®\u0005§À:eÅß±1g}È¢×«ej\u001a#`Y\u0011|ÏjÙEhH5Êf´nGë\u0016",
                "\tnÄÈVp",
                "A2õ Ì3)[1ü/ÆÐ\u0012V¶\u0017-\u0004~Ô.·X\"\t¾hÓ®^>f·Ø|\u0017'á\u0014Üc¿CHH¯Þ\u0016Z×ìãý ÎõÎÝÐYÞ·'á^ÁÚÍÊaðô£\u0001où#Ï\u0019\"\u0013*ªDÁb)-\u0015°\"æ9Xe",
                "\u00148MRâ$g±²\\\u0012)Á×Å÷È ÎjjíªK\u0004+E2\u0012Ic¹_$\u0014\u001728µ$Ê2É)QP(Éi,)¸\u0013S`#Éú¡D\u0015\u0015«×",
                "MS|èÂ+ñ¨§",
                "2\"bøÌ",
                "IÙ×4F£ýÅN\u000fØ4ÈébAÕÇlç1»ß°Ë¥Õ\")w¹¥±H©¸%±HÆðWã\u0014Ni\u000e&ìrQãs¬\u0014!BÍ©HYYs(¬ÙÆé'5\u000e",
                "k\\Ð¢q:\u0010À83,k|º\u0004\u0015",
                "²ÖÂ'©¥4Ñ¼B&Ym5\u001f&i\u0016Eó²QgÍ«JyÔP4?K8\u0016U1/È\u0005ÈÕ_kSX\u0015z(",
                "Eû3;¥*)^H",
                "ï<ÚéøØÂå%¨üìäÂT!UÊ\u0013YU\u0016¦bsx\b\u000f/ÌR1¥J)QY8Cò,",
                "Á",
                "P\u0017T¢RIYPhjAw\u0010-®hÝÉ¬qEæmH6nCEK1øe×Yù\u000fUôÔ8OÅ7º6üws\u0015ÏÉ-çx=\u0018þðZu÷àfphõ|=\u0018ºuäæuq£óA¸\u001a<³zþ©",
                "íî¼5wsîçñ;Wn_Ù}jÿ5÷\t÷s÷Õþc÷Þ¯öÚÜ7¹\u0019Z©ûü\u001fÿÉùuÛúðúµMßá»±ªohuº\u0016î®_¹w \u001a~",
                "l:\"·nÜ¼±áÿlñ·K¿Yªv¼YqÀGdï",
                "þ6¿q¤Ò;þå©?ýülµóbÅ\u0019~âB|èÃåMwg­ïµÛ½ëï¬÷Wùï>åõäöWúG",
                "ö¬ö¬ì\u001f¯x&¶oÔ¼]\u0015g×6\u0000¥0\u001fF~¶O5hÙÜG@XóÍU¿",
                "\u0005Ëß´ÛJ¢/¡¸xK\u0013¢9\u00191f2ç!c7\u0006\u0011ø|ã/!^Á9jÇ(kK \u0012)\u0006eå,°A;q%ì Ý\t\u0007ÐkVæ\u0003f\u0018óMo\u0012â|\u0012¶\u0003\u0016RÜmÝ\u0019ã\u0010÷óOÂiú¹\u0004·lÍ«ÅÔ\u0000Áqý¨×Z½=Ïã äFâ\u0001h\u0001.Kv\u0011åÿR",
                "hì²+æÊÚ\u001acÆ6ßeú0Ý\u0016doÂý!»cn",
                "\u0019Æ-&",
                "=(c\u001bðÿf¥làVJÔ\u0012¾qq%+æI4/Ý 4Ú ÞÂâHJÕ)quQ\")\u0019",
                "`É:ê\"*¡@\u0003ÀûÌ",
                "¨¡$æ°\u000eÔä],3",
                "\u0014*ä@z9è\u0000:Ç3Öz&ÅÔB\u0002Ä\u0014Å1E\u0001ò\u000e`\t\u000f/",
                "^$D ©ÊÐ",
                "¼'\u0015JJn%ê)\u000fÆTäªÞh QP\u0002T\u000fêÑ\u001f4\u001a\tD£åñéxüR|",
                "_dÙ³#\u0017ÔgÀ¯/7êÝLmÂé±÷BÓpf¤",
                ")w7SR,P\u0015\"RÊü+cø40ýD¹e\u0010.Pè\u0013eï 4ÚÜÄ\u0000GÙÕ¦a&Ø5¦",
                "Lt(\u001f88ËêmFlV\u0010°K©\u0014QL)\u0007ù\u0007øgõ*aB)4`ÃU@O»õ\u0018.\u000f\u001bÖgtjÎar#E R\u0005ù;",
                "\u0004´`R\u0007Iê9'SìMQÆ\u001f«ñj4Nã\u001a%j½\u0017h+æRÔ4£\u0013½\u00168",
                "~'1=3ùýäì",
                "Øä´æJÄcÏ]1ÖØÅÙ",
                "ç.'¦¦",
                "^Ó&êÉ×HÃ»Æé\tj-Ófà\u0003¼æ×Ý'ÍkÞÆ=LêM¶Õ\\èå×\u0002Ær§©6²2Úµ¾¼²Ið£ÙÂxØl´%",
                "l\\(kMè((^",
                "ÂÁ§\u0004ô2?â÷TÝ\u0007êÞ",
                "ßûÈÙRñØr>±ws¡G;]?ëz\u0018V#ÑÍÈ«kþ¿\u0004öÕ}íàìÖÜ\u000f",
                "ÎÕ9ñ+ßbmWÇ7Ç§ªüÑ5ïÆ¥:ßZiÞ}ÿnþþè\u001f>¸T\u0011Þ­$åÊ»",
                "¿¸Å/Cê\u0018©·ãzx}÷ZçþZäÐß½®\u000eÏ÷i\u0010µwÜ",
                "|\u0014xØv¸ÚvøîÉÍ¶××¸Ú¾¾",
                "¿¡úG¶øãµ@hÍ÷ÏGÞö\u000fÆ<¾ì\\Hw8~ÿÊý³\u0015ÿô&ÿüö\u001fßþ«\u0007vý»î",
                "íXÄ",
                "ô>Øõ¼Å\u0013\u000e\u0000þ¥",
                "rÜ8u\u0002}Þ\u0019ëá÷'BSÝ/|{'\u0007",
                "_",
                "¶²ùèÞ©ãË\b\u0007söi\u0005_7Å\u0015Ê>G(°+¢¬\u0007i^Ýé$ÜiÊ0é\u0011&\u0006èg\u00023Áêÿ\t¢½l®¿$~<_Hrä",
                ":\u0001{ìûNaííÃf³}_£Ö¯ç\t\u0002¡Uo-\u0018^",
                "ÔÚÃ«þZp÷jàp¤ÿpí³íÛ~Ë6`",
                "é°ÿ\u0005<\beá"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".git/objects/ff/6e856f1d1a69f5414c74f41791b21050034649",
                "size_bytes": 4227,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/objects/ff/7c50078536a06465d7b21503d4dfb7c47e5777",
                "size_bytes": 122,
                "status": "read_error",
                "encoding": "latin-1",
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Archivo decodificado pero contiene bytes nulos, probablemente binario."
        },
        {
            "metadata": {
                "path": ".git/refs/heads/main",
                "size_bytes": 41,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "c6c615b4c114af8ab7be388ec973a4f0af9fe67e"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".pytest_cache/.gitignore",
                "size_bytes": 39,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 2,
                "dependencias": null
            },
            "content_lines": [
                "# Created by pytest automatically.",
                "*"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".pytest_cache/CACHEDIR.TAG",
                "size_bytes": 191,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 4,
                "dependencias": null
            },
            "content_lines": [
                "Signature: 8a477f597d28d172789f06886806bc55",
                "# This file is a cache directory tag created by pytest.",
                "# For information about cache directory tags, see:",
                "#\thttps://bford.info/cachedir/spec.html"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".pytest_cache/README.md",
                "size_bytes": 310,
                "status": "ok",
                "encoding": "ascii",
                "language": "markdown",
                "line_count": 8,
                "dependencias": null
            },
            "content_lines": [
                "# pytest cache directory #",
                "",
                "This directory contains data from the pytest's cache plugin,",
                "which provides the `--lf` and `--ff` options, as well as the `cache` fixture.",
                "",
                "**Do not** commit this to version control.",
                "",
                "See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information."
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".pytest_cache/v/cache/nodeids",
                "size_bytes": 2,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "[]"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": ".pytest_cache/v/cache/stepwise",
                "size_bytes": 2,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 1,
                "dependencias": null
            },
            "content_lines": [
                "[]"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "__pycache__/ProyScan.cpython-312-pytest-7.4.4.pyc",
                "size_bytes": 17481,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "archivos.bat",
                "size_bytes": 2239,
                "status": "ok",
                "encoding": "utf-8",
                "language": "batch",
                "line_count": 48,
                "dependencias": null
            },
            "content_lines": [
                "@echo off",
                "REM Batch script para crear la estructura de archivos SumarioCommit",
                "",
                "REM Define la ruta base",
                "set basePath=SumarioCommit",
                "",
                "REM Crear el directorio raíz SumarioCommit",
                "mkdir \"%basePath%\"",
                "echo Directorio raíz \"%basePath%\" creado.",
                "",
                "REM Crear el directorio sumario_commit",
                "mkdir \"%basePath%\\sumario_commit\"",
                "echo Directorio de paquete \"%basePath%\\sumario_commit\" creado.",
                "",
                "REM Crear archivos dentro del directorio sumario_commit",
                "echo. > \"%basePath%\\sumario_commit\\__init__.py\"",
                "echo # Inicializador del paquete sumario_commit > \"%basePath%\\sumario_commit\\__init__.py\"",
                "echo. > \"%basePath%\\sumario_commit\\nucleo.py\"",
                "echo # Lógica central y orquestación > \"%basePath%\\sumario_commit\\nucleo.py\"",
                "echo. > \"%basePath%\\sumario_commit\\util_git.py\"",
                "echo # Funciones específicas para interactuar con Git > \"%basePath%\\sumario_commit\\util_git.py\"",
                "echo. > \"%basePath%\\sumario_commit\\util_ia.py\"",
                "echo # Funciones para la interacción con la API de IA (Gemini) > \"%basePath%\\sumario_commit\\util_ia.py\"",
                "echo. > \"%basePath%\\sumario_commit\\util_config.py\"",
                "echo # Funciones para gestionar la configuración (ruta, API key) > \"%basePath%\\sumario_commit\\util_config.py\"",
                "echo. > \"%basePath%\\sumario_commit\\util_debug.py\"",
                "echo # Funciones para el registro de depuración (modo debug) > \"%basePath%\\sumario_commit\\util_debug.py\"",
                "echo. > \"%basePath%\\sumario_commit\\constantes.py\"",
                "echo # Valores constantes (nombres de archivo, claves, etc.) > \"%basePath%\\sumario_commit\\constantes.py\"",
                "echo Archivos en \"%basePath%\\sumario_commit\" creados.",
                "",
                "REM Crear archivos en el directorio raíz SumarioCommit",
                "echo. > \"%basePath%\\main.py\"",
                "echo # Punto de entrada principal de la aplicación > \"%basePath%\\main.py\"",
                "echo. > \"%basePath%\\.env\"",
                "echo # Archivo para almacenar variables sensibles (API Key) - NO versionar > \"%basePath%\\.env\"",
                "echo. > \"%basePath%\\config.json\"",
                "echo {} > \"%basePath%\\config.json\"",
                "echo. > \"%basePath%\\requirements.txt\"",
                "echo requests > \"%basePath%\\requirements.txt\"",
                "echo. > \"%basePath%\\README.md\"",
                "echo # SumarioCommit > \"%basePath%\\README.md\"",
                "echo. >> \"%basePath%\\README.md\"",
                "echo Documentación básica del proyecto. >> \"%basePath%\\README.md\"",
                "echo Archivos en \"%basePath%\" creados.",
                "",
                "echo Estructura de archivos \"SumarioCommit\" creada exitosamente.",
                "pause"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "ficheros.bat",
                "size_bytes": 268,
                "status": "ok",
                "encoding": "ascii",
                "language": "batch",
                "line_count": 21,
                "dependencias": null
            },
            "content_lines": [
                "@echo off",
                "mkdir tetris",
                "cd tetris",
                "mkdir src",
                "",
                "echo. > main.py",
                "echo pygame > requirements.txt",
                "",
                "cd src",
                "echo. > __init__.py",
                "echo. > config.py",
                "echo. > piece.py",
                "echo. > grid.py",
                "echo. > game.py",
                "echo. > drawing.py",
                "echo. > gamestate.py",
                "",
                "cd ..",
                "cd ..",
                "echo Structure created!",
                "pause"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/__pycache__/main.cpython-313.pyc",
                "size_bytes": 4001,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/main.py",
                "size_bytes": 3930,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 77,
                "dependencias": [
                    {
                        "tipo": "biblioteca",
                        "path": "pygame"
                    },
                    {
                        "tipo": "biblioteca",
                        "path": "src"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "os"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "sys"
                    }
                ]
            },
            "content_lines": [
                "# main.py",
                "import sys",
                "import os",
                "import pygame # Requerido para funcionalidad principal y manejo de errores.",
                "",
                "# Bloque opcional para modificar sys.path si se ejecuta main.py directamente",
                "# y las importaciones de 'src' fallan. Es preferible ejecutar como módulo.",
                "# --- INICIO: Modificación opcional de sys.path ---",
                "# directorio_script = os.path.dirname(os.path.abspath(__file__))",
                "# directorio_padre = directorio_script",
                "# if directorio_padre not in sys.path:",
                "#     sys.path.insert(0, directorio_padre)",
                "# --- FIN: Modificación opcional de sys.path ---",
                "",
                "# Intenta importar componentes del juego desde el paquete 'src'.",
                "# Requiere ejecución desde el directorio 'tetris' (o que 'tetris' esté en sys.path).",
                "try:",
                "    from src.juego import Juego",
                "    from src.configuracion import ANCHO_PANTALLA, ALTO_PANTALLA # Usado para ventana de error.",
                "except ImportError as e:",
                "     print(f\"Error importando módulos del juego: {e}\")",
                "     print(\"Asegúrese de ejecutar este script desde el directorio 'tetris'\", file=sys.stderr)",
                "     print(f\"o ejecute como módulo: python -m main\")",
                "     print(f\"sys.path actual: {sys.path}\") # Ayuda a depurar problemas de ruta.",
                "     # Intento de mostrar ventana de error básica si pygame se cargó parcialmente.",
                "     try:",
                "         pygame.init()",
                "         pantalla = pygame.display.set_mode((600, 400)) # Tamaño básico de ventana.",
                "         pygame.display.set_caption(\"Error de Importación\")",
                "         fuente = pygame.font.SysFont('arial', 20)",
                "         texto_error1 = fuente.render(\"Error de Importación. No se encuentran los módulos 'src'.\", 1, (255,0,0))",
                "         texto_error2 = fuente.render(\"Ejecutar desde el directorio 'tetris' o usar 'python -m main'.\", 1, (255,0,0))",
                "         pantalla.fill((200, 200, 200))",
                "         pantalla.blit(texto_error1, (20, 50))",
                "         pantalla.blit(texto_error2, (20, 80))",
                "         pygame.display.flip()",
                "         while True: # Mantiene la ventana de error abierta.",
                "             for evento in pygame.event.get():",
                "                 if evento.type == pygame.QUIT: sys.exit(1)",
                "             pygame.time.wait(100)",
                "     except Exception:",
                "         pass # Falla silenciosa si ni siquiera pygame básico puede mostrar el error.",
                "     sys.exit(1) # Salida con código de error.",
                "",
                "# Punto de entrada principal si el script se ejecuta directamente.",
                "if __name__ == \"__main__\":",
                "    # Asegura que Pygame esté inicializado (Juego.__init__ lo hace).",
                "    # Manejo de errores para fallo de inicialización de Pygame.",
                "    try:",
                "        juego_tetris = Juego()",
                "        juego_tetris.ejecutar()",
                "    except pygame.error as error_pg:",
                "        print(f\"Ocurrió un error de Pygame: {error_pg}\", file=sys.stderr)",
                "        # Intento de mostrar error gráficamente si es posible.",
                "        try:",
                "            # Usa constantes importadas si están disponibles.",
                "            pantalla = pygame.display.set_mode((ANCHO_PANTALLA, ALTO_PANTALLA))",
                "            pygame.display.set_caption(\"Error de Ejecución\")",
                "            fuente = pygame.font.SysFont('arial', 20)",
                "            texto_error1 = fuente.render(f\"Error de Pygame: {error_pg}\", 1, (255,0,0))",
                "            texto_error2 = fuente.render(\"El juego encontró un error y debe cerrarse.\", 1, (255,0,0))",
                "            pantalla.fill((50, 50, 50))",
                "            pantalla.blit(texto_error1, (20, 50))",
                "            pantalla.blit(texto_error2, (20, 80))",
                "            pygame.display.flip()",
                "            while True: # Mantiene la ventana de error abierta.",
                "                for evento in pygame.event.get():",
                "                    if evento.type == pygame.QUIT: break",
                "                pygame.time.wait(100)",
                "        except Exception:",
                "            pass # Fallback a salida por consola.",
                "        pygame.quit()",
                "        sys.exit(1) # Indicar salida con error.",
                "    except Exception as e:",
                "        print(f\"Ocurrió un error inesperado: {e}\", file=sys.stderr)",
                "        pygame.quit()",
                "        sys.exit(1) # Indicar salida con error."
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/requirements.txt",
                "size_bytes": 28,
                "status": "ok",
                "encoding": "ascii",
                "language": "text",
                "line_count": 2,
                "dependencias": null
            },
            "content_lines": [
                "pygame>=2.1.0",
                "numpy>=1.20.0"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/__init__.py",
                "size_bytes": 0,
                "status": "ok",
                "encoding": "empty",
                "language": "python",
                "line_count": 0,
                "dependencias": []
            },
            "content_lines": [],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/__init__.cpython-313.pyc",
                "size_bytes": 170,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/configuracion.cpython-313.pyc",
                "size_bytes": 3074,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/cuadricula.cpython-313.pyc",
                "size_bytes": 7131,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/dibujo.cpython-313.pyc",
                "size_bytes": 18390,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/estado_juego.cpython-313.pyc",
                "size_bytes": 675,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/juego.cpython-313.pyc",
                "size_bytes": 25053,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/pieza.cpython-313.pyc",
                "size_bytes": 4865,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/__pycache__/sonido.cpython-313.pyc",
                "size_bytes": 3641,
                "status": "binary",
                "encoding": null,
                "language": "text",
                "line_count": null,
                "dependencias": null
            },
            "content_lines": null,
            "error_message": "Contenido omitido (extensión binaria: .pyc)"
        },
        {
            "metadata": {
                "path": "tetris/src/configuracion.py",
                "size_bytes": 3940,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 87,
                "dependencias": [
                    {
                        "tipo": "biblioteca",
                        "path": "pygame"
                    }
                ]
            },
            "content_lines": [
                "# src/configuracion.py",
                "import pygame",
                "",
                "# Dimensiones de Pantalla",
                "ANCHO_PANTALLA = 800",
                "ALTO_PANTALLA = 750",
                "",
                "# Dimensiones de la Cuadrícula",
                "ANCHO_CUADRICULA = 10",
                "ALTO_CUADRICULA = 20 # Filas visibles.",
                "TAMANO_BLOQUE = 30",
                "",
                "# Cálculos de posición del campo de juego",
                "ANCHO_CAMPO_JUEGO = ANCHO_CUADRICULA * TAMANO_BLOQUE",
                "ALTO_CAMPO_JUEGO = ALTO_CUADRICULA * TAMANO_BLOQUE",
                "# Centra el campo de juego en la pantalla.",
                "X_SUP_IZQ = (ANCHO_PANTALLA - ANCHO_CAMPO_JUEGO) // 2",
                "Y_SUP_IZQ = (ALTO_PANTALLA - ALTO_CAMPO_JUEGO) // 2",
                "",
                "# Colores (RGB)",
                "BLANCO = (255, 255, 255)",
                "GRIS = (128, 128, 128)",
                "GRIS_OSCURO = (50, 50, 50)",
                "NEGRO = (0, 0, 0)",
                "CIAN = (0, 255, 255)     # Pieza I.",
                "AZUL = (0, 0, 255)       # Pieza J.",
                "NARANJA = (255, 165, 0)   # Pieza L.",
                "AMARILLO = (255, 255, 0)   # Pieza O.",
                "VERDE = (0, 255, 0)      # Pieza S.",
                "PURPURA = (128, 0, 128)   # Pieza T.",
                "ROJO = (255, 0, 0)        # Pieza Z.",
                "COLOR_SELECCION_MENU = (255, 255, 0) # Amarillo para selección.",
                "",
                "# --- Colores de Título ---",
                "COLOR_TITULO_SUP = (60, 120, 255)    # Color superior para gradiente del título.",
                "COLOR_TITULO_INF = (100, 0, 200) # Color inferior para gradiente del título.",
                "COLOR_TITULO_OPCIONES = NARANJA       # Color para el título de Opciones.",
                "",
                "# Formas y Colores de Tetrominós (definición central)",
                "TETROMINOS = {",
                "    # Definiciones de forma: lista de matrices de rotación.",
                "    # Cada matriz es una lista de filas. 1 = bloque, 0 = vacío.",
                "    0: {'formas': [[[1, 1, 1, 1]], [[1], [1], [1], [1]]], 'color': CIAN}, # I",
                "    1: {'formas': [[[1, 1], [1, 1]]], 'color': AMARILLO}, # O (Solo una rotación).",
                "    2: {'formas': [[[0, 1, 0], [1, 1, 1]], [[1, 0], [1, 1], [1, 0]], [[1, 1, 1], [0, 1, 0]], [[0, 1], [1, 1], [0, 1]]], 'color': PURPURA}, # T",
                "    3: {'formas': [[[0, 1, 1], [1, 1, 0]], [[1, 0], [1, 1], [0, 1]]], 'color': VERDE}, # S",
                "    4: {'formas': [[[1, 1, 0], [0, 1, 1]], [[0, 1], [1, 1], [1, 0]]], 'color': ROJO}, # Z",
                "    5: {'formas': [[[1, 0, 0], [1, 1, 1]], [[1, 1], [1, 0], [1, 0]], [[1, 1, 1], [0, 0, 1]], [[0, 1], [0, 1], [1, 1]]], 'color': AZUL}, # J",
                "    6: {'formas': [[[0, 0, 1], [1, 1, 1]], [[1, 0], [1, 0], [1, 1]], [[1, 1, 1], [1, 0, 0]], [[1, 1], [0, 1], [0, 1]]], 'color': NARANJA} # L",
                "}",
                "",
                "# Puntuación",
                "PUNTOS_POR_LINEA = {1: 40, 2: 100, 3: 300, 4: 1200} # Puntos por líneas limpiadas a la vez.",
                "LINEAS_POR_NIVEL = 10 # Líneas necesarias para avanzar al siguiente nivel.",
                "",
                "# Tiempos del Juego",
                "VELOCIDAD_CAIDA_INICIAL = 0.8 # Segundos por paso de cuadrícula en nivel 1.",
                "DECREMENTO_VELOCIDAD_CAIDA = 0.05 # Disminución de velocidad (tiempo) por nivel.",
                "VELOCIDAD_CAIDA_MINIMA = 0.05 # Velocidad de caída más rápida posible (segundos por paso).",
                "RETRASO_REPETICION_TECLA = 200 # Retraso en ms antes de inicio de repetición de tecla.",
                "INTERVALO_REPETICION_TECLA = 40 # Intervalo para acciones de tecla repetidas (ms).",
                "",
                "# Configuraciones de Fuente",
                "# Nombres de fuente. Fallback a 'arial' si no se encuentran.",
                "NOMBRE_FUENTE_UI = 'consolas'",
                "TAMANO_FUENTE_UI = 25",
                "NOMBRE_FUENTE_TITULO_MENU = 'impact' # Fuente para el título del menú.",
                "TAMANO_FUENTE_TITULO_MENU = 70",
                "NOMBRE_FUENTE_OPCIONES_MENU = 'consolas'",
                "TAMANO_FUENTE_OPCIONES_MENU = 40",
                "NOMBRE_FUENTE_FIN_JUEGO_GRANDE = 'impact'",
                "TAMANO_FUENTE_FIN_JUEGO_GRANDE = 50",
                "NOMBRE_FUENTE_FIN_JUEGO_PEQUENA = 'consolas'",
                "TAMANO_FUENTE_FIN_JUEGO_PEQUENA = 30",
                "NOMBRE_FUENTE_TITULO_PAUSA = 'impact'",
                "TAMANO_FUENTE_TITULO_PAUSA = 60",
                "",
                "# Posiciones de la UI (Relativas a la pantalla o campo de juego)",
                "# Área para mostrar la siguiente pieza.",
                "X_AREA_SIG_PIEZA = X_SUP_IZQ + ANCHO_CAMPO_JUEGO + 50",
                "Y_AREA_SIG_PIEZA = Y_SUP_IZQ + 70",
                "# Área para mostrar puntuación, nivel, líneas (a la izquierda del campo de juego).",
                "X_AREA_PUNTUACION = X_SUP_IZQ - 200 if X_SUP_IZQ - 200 > 20 else 20 # Con margen mínimo.",
                "Y_INICIO_AREA_PUNTUACION = Y_SUP_IZQ + 50",
                "",
                "# Transparencia de la pieza fantasma (0=invisible, 255=opaco)",
                "ALFA_FANTASMA = 90"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/cuadricula.py",
                "size_bytes": 8782,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 167,
                "dependencias": [
                    {
                        "path": "tetris/src/configuracion.py",
                        "tipo": "interna"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "sys"
                    }
                ]
            },
            "content_lines": [
                "# src/cuadricula.py",
                "from .configuracion import ANCHO_CUADRICULA, ALTO_CUADRICULA, NEGRO",
                "import sys # Para impresión de depuración.",
                "",
                "def crear_cuadricula(posiciones_bloqueadas={}):",
                "    \"\"\"",
                "    Crea la estructura de datos principal de la cuadrícula del juego (lista de listas)",
                "    basada en las posiciones bloqueadas.",
                "    \"\"\"",
                "    # Inicializa una cuadrícula vacía (llena de color NEGRO).",
                "    cuadricula = [[NEGRO for _ in range(ANCHO_CUADRICULA)] for _ in range(ALTO_CUADRICULA)]",
                "    # Rellena la cuadrícula con los bloques de las posiciones bloqueadas.",
                "    for (f, c), color in posiciones_bloqueadas.items():",
                "        # Asegura que las claves sean válidas y estén dentro de los límites de la cuadrícula antes de asignar.",
                "        if isinstance(f, int) and isinstance(c, int) and 0 <= f < ALTO_CUADRICULA and 0 <= c < ANCHO_CUADRICULA:",
                "             # Comprueba si el color es una tupla válida de 3 elementos (RGB).",
                "             if isinstance(color, tuple) and len(color) == 3:",
                "                cuadricula[f][c] = color",
                "             else:",
                "                 # Advierte si se encuentra un color inválido.",
                "                 print(f\"DEBUG: Valor de color inválido {color} para clave ({f},{c}) en crear_cuadricula\", file=sys.stderr)",
                "        # Ignora silenciosamente claves/posiciones inválidas fuera de los límites.",
                "    return cuadricula",
                "",
                "def es_posicion_valida(pieza, posiciones_bloqueadas, verificar_x=None, verificar_y=None):",
                "    \"\"\"",
                "    Comprueba si la posición potencial de una pieza es válida.",
                "",
                "    Validez significa:",
                "    1. Todos los bloques están dentro de los límites horizontales (0 <= c < ANCHO_CUADRICULA).",
                "    2. Todos los bloques están dentro del límite inferior (f < ALTO_CUADRICULA).",
                "    3. La posición exacta (f, c) de ningún bloque existe como clave en el diccionario posiciones_bloqueadas.",
                "",
                "    Args:",
                "        pieza (Pieza): El objeto pieza a comprobar.",
                "        posiciones_bloqueadas (dict): El diccionario que representa todos los bloques bloqueados {(f,c): color}.",
                "        verificar_x (int, optional): La columna a comprobar para el origen de la pieza. Por defecto, pieza.x.",
                "        verificar_y (int, optional): La fila a comprobar para el origen de la pieza. Por defecto, pieza.y.",
                "",
                "    Returns:",
                "        bool: True si la posición es válida, False en caso contrario.",
                "    \"\"\"",
                "    # Determina la posición a comprobar (ya sea la pasada o la actual de la pieza).",
                "    pos_x = verificar_x if verificar_x is not None else pieza.x",
                "    pos_y = verificar_y if verificar_y is not None else pieza.y",
                "",
                "    # Obtiene las coordenadas absolutas de la cuadrícula para cada bloque en la posición potencial.",
                "    posiciones_potenciales_bloques = pieza.obtener_posiciones_bloques(cuadricula_x=pos_x, cuadricula_y=pos_y)",
                "",
                "    for f, c in posiciones_potenciales_bloques:",
                "        # --- Comprobaciones de Límites ---",
                "        # Comprobar límites horizontales.",
                "        if not (0 <= c < ANCHO_CUADRICULA):",
                "            return False",
                "        # Comprobar límite inferior.",
                "        if f >= ALTO_CUADRICULA:",
                "            return False",
                "        # Nota: No hay comprobación explícita del límite superior (f < 0 está permitido).",
                "",
                "        # --- Comprobación de Colisión ---",
                "        # Comprueba directamente si la posición potencial del bloque existe en posiciones_bloqueadas.",
                "        if (f, c) in posiciones_bloqueadas:",
                "            # Colisión detectada: Posición inválida.",
                "            return False",
                "",
                "    # Si todos los bloques pasaron las comprobaciones de límites y colisión.",
                "    return True",
                "",
                "def bloquear_pieza(pieza, posiciones_bloqueadas):",
                "    \"\"\"",
                "    Añade los bloques de la pieza que está cayendo actualmente al diccionario posiciones_bloqueadas.",
                "    Incluye bloques potencialmente por encima de la pantalla visible (f < 0).",
                "    \"\"\"",
                "    for f, c in pieza.obtener_posiciones_bloques():",
                "        # Solo bloquear bloques que no terminen debajo de la cuadrícula visible.",
                "        if f < ALTO_CUADRICULA:",
                "            # Asegura que el color de la pieza sea válido antes de añadirlo.",
                "            if isinstance(pieza.color, tuple) and len(pieza.color) == 3:",
                "                 posiciones_bloqueadas[(f, c)] = pieza.color",
                "            else:",
                "                 # Advierte si se intenta bloquear una pieza con color inválido.",
                "                 print(f\"DEBUG: Intento de bloquear pieza con color inválido: {pieza.color}\", file=sys.stderr)",
                "",
                "def limpiar_lineas(posiciones_bloqueadas):",
                "    \"\"\"",
                "    Comprueba y elimina las líneas completadas de las posiciones_bloqueadas.",
                "    Desplaza hacia abajo los bloques por encima de las líneas limpiadas. Incluye comprobaciones defensivas.",
                "    \"\"\"",
                "    lineas_limpiadas = 0",
                "    filas_completas = []",
                "",
                "    # Si no hay bloques bloqueados, no hay nada que limpiar.",
                "    if not posiciones_bloqueadas: return 0, posiciones_bloqueadas",
                "",
                "    # --- Encontrar Filas Completas ---",
                "    # Comprueba las filas de la cuadrícula, de abajo hacia arriba.",
                "    for f in range(ALTO_CUADRICULA -1, -1, -1):",
                "        esta_llena = True",
                "        for c in range(ANCHO_CUADRICULA):",
                "            # Usa .get() para un acceso más seguro al diccionario.",
                "            if posiciones_bloqueadas.get((f, c)) is None:",
                "                esta_llena = False",
                "                break # Fila no completa, pasar a la siguiente.",
                "        if esta_llena:",
                "            lineas_limpiadas += 1",
                "            filas_completas.append(f) # Añade el índice de la fila completa.",
                "",
                "    # --- Reconstruir Posiciones Bloqueadas si se Limpiaron Líneas ---",
                "    if lineas_limpiadas > 0:",
                "        nuevas_posiciones_bloqueadas = {}",
                "        try:",
                "            # Ordena los índices de las filas completas (ascendente).",
                "            filas_completas.sort()",
                "        except Exception as e:",
                "             # Si falla la ordenación, aborta la limpieza para evitar errores.",
                "             print(f\"DEBUG: Error ordenando filas_completas: {filas_completas}. Error: {e}\", file=sys.stderr)",
                "             return 0, posiciones_bloqueadas",
                "",
                "        # Iterar sobre copia de claves para reconstrucción segura.",
                "        for clave_pos in list(posiciones_bloqueadas.keys()):",
                "            # Validación básica de la clave del diccionario.",
                "            if not (isinstance(clave_pos, tuple) and len(clave_pos) == 2 and",
                "                    isinstance(clave_pos[0], int) and isinstance(clave_pos[1], int)):",
                "                print(f\"DEBUG: Clave inválida en posiciones_bloqueadas: {clave_pos}. Omitiendo.\", file=sys.stderr)",
                "                continue",
                "",
                "            f, c = clave_pos # Desempaqueta fila y columna.",
                "",
                "            # Si la fila del bloque no está entre las completadas, se conserva.",
                "            if f not in filas_completas:",
                "                try:",
                "                    # Calcular desplazamiento basado en líneas limpiadas debajo.",
                "                    desplazamiento = sum(1 for f_limpiada in filas_completas if f_limpiada > f)",
                "                except TypeError as e:",
                "                    print(f\"DEBUG: TypeError durante cálculo de desplazamiento para f={f}. Error: {e}\", file=sys.stderr)",
                "                    desplazamiento = 0 # Por defecto, sin desplazamiento si falla el cálculo.",
                "                    nueva_clave_pos = clave_pos",
                "                else:",
                "                     # Añade el bloque al nuevo diccionario en su posición desplazada.",
                "                     nueva_clave_pos = (f + desplazamiento, c)",
                "",
                "                # Valida el valor antes de la asignación.",
                "                valor_a_asignar = posiciones_bloqueadas.get(clave_pos) # Usa get por seguridad.",
                "                if isinstance(valor_a_asignar, tuple) and len(valor_a_asignar) == 3:",
                "                    nuevas_posiciones_bloqueadas[nueva_clave_pos] = valor_a_asignar",
                "                else:",
                "                     # Advierte si se encuentra un valor inválido.",
                "                     print(f\"DEBUG: Valor inválido encontrado para clave {clave_pos}: {valor_a_asignar}. Omitiendo asignación.\", file=sys.stderr)",
                "",
                "        # Devuelve el número de líneas limpiadas y el diccionario reconstruido.",
                "        return lineas_limpiadas, nuevas_posiciones_bloqueadas",
                "",
                "    # No se limpiaron líneas, devuelve 0 y el diccionario original.",
                "    return lineas_limpiadas, posiciones_bloqueadas",
                "",
                "def calcular_posicion_fantasma(pieza, posiciones_bloqueadas):",
                "    \"\"\"",
                "    Encuentra la posición y (índice de fila) válida más baja para la pieza",
                "    basándose en las posiciones_bloqueadas.",
                "    \"\"\"",
                "    fantasma_y = pieza.y",
                "    # Comprueba hacia abajo paso a paso hasta encontrar una posición inválida.",
                "    # La validación usa posiciones_bloqueadas.",
                "    while es_posicion_valida(pieza, posiciones_bloqueadas, verificar_y=fantasma_y + 1):",
                "        fantasma_y += 1",
                "    # La última posición válida es la 'fantasma_y' actual.",
                "    return fantasma_y"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/dibujo.py",
                "size_bytes": 15125,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 279,
                "dependencias": [
                    {
                        "tipo": "biblioteca",
                        "path": "pygame"
                    },
                    {
                        "path": "tetris/src/__init__.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/pieza.py",
                        "tipo": "interna"
                    }
                ]
            },
            "content_lines": [
                "# src/dibujo.py",
                "import pygame",
                "# Importa configuracion usando el alias cfg",
                "from . import configuracion as cfg",
                "from .pieza import Pieza",
                "",
                "# --- Gestión de Fuentes ---",
                "_fuentes = {} # Caché para objetos de fuente cargados",
                "",
                "def obtener_fuente(nombre, tamano):",
                "    \"\"\"",
                "    Obtiene un objeto pygame.font.Font desde el caché o lo carga.",
                "",
                "    Args:",
                "        nombre (str): Nombre de la fuente del sistema.",
                "        tamano (int): Tamaño de la fuente en puntos.",
                "",
                "    Returns:",
                "        pygame.font.Font: El objeto de fuente cargado o cacheado.",
                "    \"\"\"",
                "    clave = (nombre, tamano)",
                "    if clave not in _fuentes:",
                "        try:",
                "            # Intenta cargar la fuente especificada.",
                "            _fuentes[clave] = pygame.font.SysFont(nombre, tamano, bold=True)",
                "        except pygame.error as e:",
                "             # Fallback a fuente 'arial' si la solicitada no se encuentra.",
                "             print(f\"Advertencia: Fuente '{nombre}' no encontrada, usando predeterminada. Error: {e}\")",
                "             clave_fuente_predet = ('arial', tamano)",
                "             if clave_fuente_predet not in _fuentes:",
                "                 _fuentes[clave_fuente_predet] = pygame.font.SysFont('arial', tamano, bold=True)",
                "             _fuentes[clave] = _fuentes[clave_fuente_predet] # Usa la fuente predeterminada para la clave original.",
                "    return _fuentes[clave]",
                "",
                "# --- Ayudantes Básicos de Dibujo ---",
                "",
                "def dibujar_texto(superficie, texto, tamano, x, y, color=cfg.BLANCO, nombre_fuente=cfg.NOMBRE_FUENTE_UI):",
                "    \"\"\"Dibuja texto en una superficie usando fuentes cacheadas.\"\"\"",
                "    fuente = obtener_fuente(nombre_fuente, tamano)",
                "    etiqueta = fuente.render(texto, 1, color) # 1 habilita anti-aliasing.",
                "    superficie.blit(etiqueta, (x, y))",
                "",
                "def _dibujar_superposicion_menu(superficie):",
                "    \"\"\"Dibuja una superposición semitransparente, usada típicamente detrás de los menús.\"\"\"",
                "    # pygame.SRCALPHA permite transparencia por píxel.",
                "    superposicion = pygame.Surface((cfg.ANCHO_PANTALLA, cfg.ALTO_PANTALLA), pygame.SRCALPHA)",
                "    superposicion.fill((0, 0, 0, 180)) # Negro con 180/255 alfa (~70% opaco).",
                "    superficie.blit(superposicion, (0, 0))",
                "",
                "# --- Elementos del Tablero de Juego ---",
                "",
                "def dibujar_lineas_cuadricula(superficie):",
                "    \"\"\"Dibuja las líneas de la cuadrícula de fondo para el campo de juego.\"\"\"",
                "    for f in range(cfg.ALTO_CUADRICULA + 1):",
                "        pygame.draw.line(superficie, cfg.GRIS_OSCURO, # Color más oscuro para líneas sutiles.",
                "                         (cfg.X_SUP_IZQ, cfg.Y_SUP_IZQ + f * cfg.TAMANO_BLOQUE),",
                "                         (cfg.X_SUP_IZQ + cfg.ANCHO_CAMPO_JUEGO, cfg.Y_SUP_IZQ + f * cfg.TAMANO_BLOQUE))",
                "    for c in range(cfg.ANCHO_CUADRICULA + 1):",
                "        pygame.draw.line(superficie, cfg.GRIS_OSCURO,",
                "                         (cfg.X_SUP_IZQ + c * cfg.TAMANO_BLOQUE, cfg.Y_SUP_IZQ),",
                "                         (cfg.X_SUP_IZQ + c * cfg.TAMANO_BLOQUE, cfg.Y_SUP_IZQ + cfg.ALTO_CAMPO_JUEGO))",
                "",
                "def dibujar_borde_campo_juego(superficie):",
                "    \"\"\"Dibuja un borde alrededor del área del campo de juego.\"\"\"",
                "    # Borde de 2px de grosor.",
                "    pygame.draw.rect(superficie, cfg.BLANCO,",
                "                     (cfg.X_SUP_IZQ - 2, cfg.Y_SUP_IZQ - 2, cfg.ANCHO_CAMPO_JUEGO + 4, cfg.ALTO_CAMPO_JUEGO + 4), 2)",
                "",
                "def dibujar_bloques_cuadricula(superficie, cuadricula):",
                "    \"\"\"Dibuja los bloques bloqueados actualmente en la cuadrícula.\"\"\"",
                "    for f in range(cfg.ALTO_CUADRICULA):",
                "        for c in range(cfg.ANCHO_CUADRICULA):",
                "            color = cuadricula[f][c]",
                "            if color != cfg.NEGRO: # Omite el dibujo de celdas vacías.",
                "                # Calcula coordenadas de pantalla para el bloque.",
                "                pantalla_x = cfg.X_SUP_IZQ + c * cfg.TAMANO_BLOQUE",
                "                pantalla_y = cfg.Y_SUP_IZQ + f * cfg.TAMANO_BLOQUE",
                "",
                "                # Dibuja color principal del bloque.",
                "                pygame.draw.rect(superficie, color,",
                "                                 (pantalla_x, pantalla_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 0) # 0 = relleno.",
                "                # Dibuja borde sutil para definición.",
                "                pygame.draw.rect(superficie, cfg.GRIS,",
                "                                 (pantalla_x, pantalla_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 1) # 1 = borde de 1px.",
                "",
                "# --- Piezas de Tetrominó ---",
                "",
                "def dibujar_pieza(superficie, pieza: Pieza):",
                "    \"\"\"Dibuja la pieza que está cayendo actualmente en su posición.\"\"\"",
                "    posiciones_bloques = pieza.obtener_posiciones_bloques()",
                "",
                "    for f, c in posiciones_bloques:",
                "        # Dibuja solo bloques dentro o por encima del área visible de la cuadrícula verticalmente.",
                "        if f < cfg.ALTO_CUADRICULA:",
                "            # Calcula coordenadas de pantalla.",
                "            pantalla_x = cfg.X_SUP_IZQ + c * cfg.TAMANO_BLOQUE",
                "            pantalla_y = cfg.Y_SUP_IZQ + f * cfg.TAMANO_BLOQUE",
                "",
                "            # Renderiza solo si el bloque está en pantalla verticalmente (f >= 0).",
                "            if pantalla_y >= cfg.Y_SUP_IZQ:",
                "                pygame.draw.rect(superficie, pieza.color,",
                "                                (pantalla_x, pantalla_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 0)",
                "                pygame.draw.rect(superficie, cfg.GRIS, # Añade borde.",
                "                                (pantalla_x, pantalla_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 1)",
                "",
                "def dibujar_pieza_fantasma(superficie, pieza: Pieza, fantasma_y: int):",
                "    \"\"\"Dibuja un 'fantasma' semitransparente de la pieza donde aterrizaría.\"\"\"",
                "    # Obtiene posiciones en la Y fantasma calculada.",
                "    posiciones_bloques = pieza.obtener_posiciones_bloques(cuadricula_y=fantasma_y)",
                "",
                "    for f, c in posiciones_bloques:",
                "        # Dibuja solo bloques dentro de los límites visibles de la cuadrícula.",
                "        if 0 <= f < cfg.ALTO_CUADRICULA and 0 <= c < cfg.ANCHO_CUADRICULA:",
                "            pantalla_x = cfg.X_SUP_IZQ + c * cfg.TAMANO_BLOQUE",
                "            pantalla_y = cfg.Y_SUP_IZQ + f * cfg.TAMANO_BLOQUE",
                "",
                "            # Crea una superficie temporal para el bloque transparente.",
                "            s = pygame.Surface((cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), pygame.SRCALPHA)",
                "            # Usa el color de la pieza pero con el alfa especificado.",
                "            s.fill((*pieza.color, cfg.ALFA_FANTASMA))",
                "            superficie.blit(s, (pantalla_x, pantalla_y))",
                "",
                "def dibujar_siguiente_pieza(superficie, pieza: Pieza):",
                "    \"\"\"Dibuja la vista previa de la siguiente pieza en su área designada.\"\"\"",
                "    sx = cfg.X_AREA_SIG_PIEZA",
                "    sy = cfg.Y_AREA_SIG_PIEZA",
                "",
                "    dibujar_texto(superficie, \"Siguiente:\", cfg.TAMANO_FUENTE_UI, sx, sy - 40, color=cfg.BLANCO, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "",
                "    # Usa la rotación base (índice 0) para una visualización de vista previa consistente.",
                "    forma = pieza.formas[0]",
                "    alto_forma = len(forma)",
                "    ancho_forma = len(forma[0]) if alto_forma > 0 else 0",
                "",
                "    # Calcula esquina superior izquierda para centrar la forma de vista previa.",
                "    # Ajusta el centrado basado en las dimensiones reales de la forma.",
                "    ancho_area_previa = 4 * cfg.TAMANO_BLOQUE",
                "    alto_area_previa = 4 * cfg.TAMANO_BLOQUE",
                "    inicio_dibujo_x = sx + (ancho_area_previa - ancho_forma * cfg.TAMANO_BLOQUE) // 2",
                "    inicio_dibujo_y = sy + (alto_area_previa - alto_forma * cfg.TAMANO_BLOQUE) // 2",
                "",
                "    # Dibuja los bloques de la forma de vista previa.",
                "    for idx_f, fila in enumerate(forma):",
                "        for idx_c, celda in enumerate(fila):",
                "            if celda == 1: # 1 indica un bloque.",
                "                dibujar_x = inicio_dibujo_x + idx_c * cfg.TAMANO_BLOQUE",
                "                dibujar_y = inicio_dibujo_y + idx_f * cfg.TAMANO_BLOQUE",
                "                pygame.draw.rect(superficie, pieza.color,",
                "                                 (dibujar_x, dibujar_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 0)",
                "                pygame.draw.rect(superficie, cfg.GRIS, # Añade borde.",
                "                                 (dibujar_x, dibujar_y, cfg.TAMANO_BLOQUE, cfg.TAMANO_BLOQUE), 1)",
                "",
                "# --- Elementos de la Interfaz de Usuario (UI) ---",
                "",
                "def dibujar_ui(superficie, puntuacion: int, nivel: int, lineas: int):",
                "    \"\"\"Dibuja los elementos de la UI: puntuación, nivel y líneas limpiadas.\"\"\"",
                "    ui_x = cfg.X_AREA_PUNTUACION",
                "    ui_y = cfg.Y_INICIO_AREA_PUNTUACION",
                "",
                "    # Visualización de Puntuación",
                "    dibujar_texto(superficie, \"Puntuación:\", cfg.TAMANO_FUENTE_UI, ui_x, ui_y, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "    dibujar_texto(superficie, f\"{puntuacion}\", cfg.TAMANO_FUENTE_UI, ui_x + 10, ui_y + 30, nombre_fuente=cfg.NOMBRE_FUENTE_UI) # Valor debajo.",
                "",
                "    # Visualización de Nivel",
                "    dibujar_texto(superficie, \"Nivel:\", cfg.TAMANO_FUENTE_UI, ui_x, ui_y + 80, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "    dibujar_texto(superficie, f\"{nivel}\", cfg.TAMANO_FUENTE_UI, ui_x + 10, ui_y + 110, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "",
                "    # Visualización de Líneas Limpiadas",
                "    dibujar_texto(superficie, \"Líneas:\", cfg.TAMANO_FUENTE_UI, ui_x, ui_y + 160, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "    dibujar_texto(superficie, f\"{lineas}\", cfg.TAMANO_FUENTE_UI, ui_x + 10, ui_y + 190, nombre_fuente=cfg.NOMBRE_FUENTE_UI)",
                "",
                "# --- Pantallas de Menú ---",
                "",
                "def dibujar_menu_principal(superficie, opcion_seleccionada: int, opciones: list[str]):",
                "    \"\"\"Dibuja la pantalla del menú principal con título rediseñado.\"\"\"",
                "    superficie.fill(cfg.NEGRO)",
                "    texto_titulo = \"PyTetris\"",
                "    fuente_titulo = obtener_fuente(cfg.NOMBRE_FUENTE_TITULO_MENU, cfg.TAMANO_FUENTE_TITULO_MENU)",
                "    titulo_x = cfg.ANCHO_PANTALLA // 2",
                "    titulo_y = cfg.ALTO_PANTALLA // 3 - fuente_titulo.get_height() // 2 # Centrado vertical.",
                "    desplazamiento_gradiente = 3 # Desplazamiento en píxeles para el efecto gradiente.",
                "",
                "    # --- Dibujar Título Principal con Gradiente ---",
                "    # Renderiza color inferior ligeramente desplazado.",
                "    etiqueta_titulo_inf = fuente_titulo.render(texto_titulo, 1, cfg.COLOR_TITULO_INF)",
                "    rect_titulo_inf = etiqueta_titulo_inf.get_rect(center=(titulo_x, titulo_y + desplazamiento_gradiente))",
                "    superficie.blit(etiqueta_titulo_inf, rect_titulo_inf)",
                "",
                "    # Renderiza color superior normalmente.",
                "    etiqueta_titulo_sup = fuente_titulo.render(texto_titulo, 1, cfg.COLOR_TITULO_SUP)",
                "    rect_titulo_sup = etiqueta_titulo_sup.get_rect(center=(titulo_x, titulo_y))",
                "    superficie.blit(etiqueta_titulo_sup, rect_titulo_sup)",
                "    # --- Fin Gradiente Título ---",
                "",
                "    # Dibujar Opciones",
                "    fuente_opcion = obtener_fuente(cfg.NOMBRE_FUENTE_OPCIONES_MENU, cfg.TAMANO_FUENTE_OPCIONES_MENU)",
                "    opcion_y_inicio = cfg.ALTO_PANTALLA // 2",
                "    espaciado_opcion = 50",
                "    for i, nombre_opcion in enumerate(opciones):",
                "        color = cfg.COLOR_SELECCION_MENU if i == opcion_seleccionada else cfg.BLANCO",
                "        # Nota: La lógica anterior para atenuar \"Opciones\" ha sido eliminada.",
                "",
                "        etiqueta_opcion = fuente_opcion.render(nombre_opcion, 1, color)",
                "        rect_opcion = etiqueta_opcion.get_rect(center=(cfg.ANCHO_PANTALLA // 2, opcion_y_inicio + i * espaciado_opcion))",
                "        superficie.blit(etiqueta_opcion, rect_opcion)",
                "",
                "def dibujar_menu_pausa(superficie, opcion_seleccionada: int, opciones: list[str]):",
                "    \"\"\"Dibuja la superposición del menú de pausa.\"\"\"",
                "    _dibujar_superposicion_menu(superficie) # Atenúa el juego de fondo.",
                "",
                "    # Dibujar Título \"Pausado\"",
                "    fuente_titulo = obtener_fuente(cfg.NOMBRE_FUENTE_TITULO_PAUSA, cfg.TAMANO_FUENTE_TITULO_PAUSA)",
                "    etiqueta_titulo = fuente_titulo.render(\"PAUSADO\", 1, cfg.AMARILLO)",
                "    titulo_x = cfg.ANCHO_PANTALLA // 2 - etiqueta_titulo.get_width() // 2",
                "    titulo_y = cfg.ALTO_PANTALLA // 3",
                "    superficie.blit(etiqueta_titulo, (titulo_x, titulo_y))",
                "",
                "    # Dibujar Opciones de Pausa",
                "    fuente_opcion = obtener_fuente(cfg.NOMBRE_FUENTE_OPCIONES_MENU, cfg.TAMANO_FUENTE_OPCIONES_MENU)",
                "    opcion_y_inicio = cfg.ALTO_PANTALLA // 2 + 30 # Posición debajo del título.",
                "    espaciado_opcion = 50",
                "    for i, opcion in enumerate(opciones):",
                "        color = cfg.COLOR_SELECCION_MENU if i == opcion_seleccionada else cfg.BLANCO",
                "        etiqueta_opcion = fuente_opcion.render(opcion, 1, color)",
                "        opcion_x = cfg.ANCHO_PANTALLA // 2 - etiqueta_opcion.get_width() // 2",
                "        opcion_y = opcion_y_inicio + i * espaciado_opcion",
                "        superficie.blit(etiqueta_opcion, (opcion_x, opcion_y))",
                "",
                "def dibujar_fin_juego(superficie):",
                "    \"\"\"Dibuja la superposición de la pantalla de fin de juego.\"\"\"",
                "    _dibujar_superposicion_menu(superficie) # Atenúa el juego de fondo.",
                "",
                "    # Obtener fuentes.",
                "    fuente_grande = obtener_fuente(cfg.NOMBRE_FUENTE_FIN_JUEGO_GRANDE, cfg.TAMANO_FUENTE_FIN_JUEGO_GRANDE)",
                "    fuente_pequena = obtener_fuente(cfg.NOMBRE_FUENTE_FIN_JUEGO_PEQUENA, cfg.TAMANO_FUENTE_FIN_JUEGO_PEQUENA)",
                "",
                "    # Dibujar Texto \"FIN DEL JUEGO\".",
                "    etiqueta_fin_juego = fuente_grande.render(\"FIN DEL JUEGO\", 1, cfg.ROJO)",
                "    # Posición más alta.",
                "    superficie.blit(etiqueta_fin_juego, (cfg.ANCHO_PANTALLA // 2 - etiqueta_fin_juego.get_width() // 2, cfg.ALTO_PANTALLA // 2 - 60))",
                "",
                "    # Dibujar Instrucciones.",
                "    etiqueta_reiniciar = fuente_pequena.render(\"Pulsa 'R' para Jugar de Nuevo\", 1, cfg.BLANCO)",
                "    superficie.blit(etiqueta_reiniciar, (cfg.ANCHO_PANTALLA // 2 - etiqueta_reiniciar.get_width() // 2, cfg.ALTO_PANTALLA // 2 + 20))",
                "",
                "    etiqueta_menu = fuente_pequena.render(\"Pulsa 'M' para Menú Principal\", 1, cfg.BLANCO)",
                "    superficie.blit(etiqueta_menu, (cfg.ANCHO_PANTALLA // 2 - etiqueta_menu.get_width() // 2, cfg.ALTO_PANTALLA // 2 + 60))",
                "",
                "def dibujar_menu_opciones(superficie, opcion_seleccionada: int, opciones: list[str], estado_sonido_activado: bool):",
                "    \"\"\"Dibuja la pantalla del menú de opciones con título rediseñado.\"\"\"",
                "    superficie.fill(cfg.NEGRO)",
                "    texto_titulo = \"Opciones\"",
                "    fuente_titulo = obtener_fuente(cfg.NOMBRE_FUENTE_TITULO_MENU, cfg.TAMANO_FUENTE_TITULO_MENU)",
                "    fuente_opcion = obtener_fuente(cfg.NOMBRE_FUENTE_OPCIONES_MENU, cfg.TAMANO_FUENTE_OPCIONES_MENU)",
                "",
                "    # --- Dibujar Título de Opciones ---",
                "    etiqueta_titulo = fuente_titulo.render(texto_titulo, 1, cfg.COLOR_TITULO_OPCIONES) # Color específico para este título.",
                "    rect_titulo = etiqueta_titulo.get_rect(center=(cfg.ANCHO_PANTALLA // 2, cfg.ALTO_PANTALLA // 4))",
                "    superficie.blit(etiqueta_titulo, rect_titulo)",
                "    # --- Fin Título de Opciones ---",
                "",
                "    # Dibujar Elementos de Opción",
                "    opcion_y_inicio = cfg.ALTO_PANTALLA // 2 - 50",
                "    espaciado_opcion = 60",
                "    for i, nombre_opcion in enumerate(opciones):",
                "        color = cfg.COLOR_SELECCION_MENU if i == opcion_seleccionada else cfg.BLANCO",
                "        texto_mostrar = \"\"",
                "        if nombre_opcion == \"Sonidos\":",
                "            # Muestra ON/OFF según el estado del flag booleano.",
                "            texto_estado = \"ON\" if estado_sonido_activado else \"OFF\"",
                "            texto_mostrar = f\"Sonidos: [{texto_estado}]\"",
                "        elif nombre_opcion == \"Volver\":",
                "            texto_mostrar = \"Volver al Menú\"",
                "        else:",
                "            texto_mostrar = nombre_opcion # Para futuras opciones.",
                "",
                "        etiqueta_opcion = fuente_opcion.render(texto_mostrar, 1, color)",
                "        rect_opcion = etiqueta_opcion.get_rect(center=(cfg.ANCHO_PANTALLA // 2, opcion_y_inicio + i * espaciado_opcion))",
                "        superficie.blit(etiqueta_opcion, rect_opcion)"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/estado_juego.py",
                "size_bytes": 463,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 10,
                "dependencias": [
                    {
                        "tipo": "stdlib",
                        "path": "enum"
                    }
                ]
            },
            "content_lines": [
                "# src/estado_juego.py",
                "from enum import Enum, auto",
                "",
                "class EstadoJuego(Enum):",
                "    \"\"\"Representa los posibles estados del juego.\"\"\"",
                "    MENU = auto()       # Menú principal está activo",
                "    OPCIONES = auto()    # Menú de opciones está activo <--- AÑADIDO",
                "    JUGANDO = auto()     # La jugabilidad está activa",
                "    PAUSADO = auto()     # Menú de pausa está activo sobre la pantalla de juego",
                "    FIN_JUEGO = auto()  # Pantalla de fin de juego se muestra"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/juego.py",
                "size_bytes": 23323,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 404,
                "dependencias": [
                    {
                        "tipo": "biblioteca",
                        "path": "pprint"
                    },
                    {
                        "tipo": "biblioteca",
                        "path": "pygame"
                    },
                    {
                        "path": "tetris/src/__init__.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/cuadricula.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/dibujo.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/estado_juego.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/pieza.py",
                        "tipo": "interna"
                    },
                    {
                        "path": "tetris/src/sonido.py",
                        "tipo": "interna"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "sys"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "time"
                    }
                ]
            },
            "content_lines": [
                "# src/juego.py",
                "import pygame",
                "import sys",
                "import time",
                "import pprint",
                "",
                "# Importar componentes necesarios",
                "from . import configuracion as conf # Importa configuracion usando el alias conf",
                "from .estado_juego import EstadoJuego",
                "from .pieza import Pieza, obtener_pieza_aleatoria",
                "from .cuadricula import (crear_cuadricula, es_posicion_valida, bloquear_pieza,",
                "                   limpiar_lineas, calcular_posicion_fantasma)",
                "# Se importan las funciones de dibujo necesarias",
                "from .dibujo import (dibujar_lineas_cuadricula, dibujar_borde_campo_juego, dibujar_bloques_cuadricula,",
                "                    dibujar_pieza, dibujar_pieza_fantasma, dibujar_siguiente_pieza, dibujar_ui,",
                "                    dibujar_menu_principal, dibujar_menu_pausa, dibujar_menu_opciones,",
                "                    dibujar_fin_juego)",
                "from .sonido import crear_sonido_colocar",
                "",
                "class Juego:",
                "    def __init__(self):",
                "        \"\"\"Inicializa Pygame, sonido, pantalla, reloj y estado inicial del juego.\"\"\"",
                "        try:",
                "            # Pre-inicializa el mezclador con configuraciones recomendadas.",
                "            pygame.mixer.pre_init(frequency=44100, size=-16, channels=2, buffer=512)",
                "            pygame.init()",
                "            pygame.font.init()",
                "            # Inicialización del mezclador (después de pygame.init).",
                "            print(\"Inicializando mezclador DESPUÉS de pygame.init()...\")",
                "            try:",
                "                pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)",
                "                config_mezclador = pygame.mixer.get_init()",
                "                if config_mezclador: print(f\"Mezclador inicializado con config: Freq={config_mezclador[0]}, Formato={config_mezclador[1]}, Canales={config_mezclador[2]}\")",
                "                else: print(\"ERROR: pygame.mixer.get_init() devolvió None!\", file=sys.stderr)",
                "            except pygame.error as err_mezclador:",
                "                 print(f\"ERROR: Falló la inicialización del mezclador: {err_mezclador}\", file=sys.stderr)",
                "                 pygame.quit(); sys.exit(1) # Salir si la inicialización del sonido falla.",
                "        except pygame.error as e:",
                "            print(f\"Error inicializando el núcleo de Pygame: {e}\", file=sys.stderr)",
                "            sys.exit(1)",
                "",
                "        self.pantalla = pygame.display.set_mode((conf.ANCHO_PANTALLA, conf.ALTO_PANTALLA))",
                "        pygame.display.set_caption(\"PyTetris - Menú Opciones\") # Título de la ventana.",
                "        self.reloj = pygame.time.Clock()",
                "",
                "        # --- Configuración de Sonido ---",
                "        self.sonido_colocar = crear_sonido_colocar()",
                "        # Flag para controlar si el sonido está activado.",
                "        self.es_sonido_activado = True",
                "",
                "        # --- Estado del Juego y Menús ---",
                "        self.estado_juego = EstadoJuego.MENU",
                "        self.en_ejecucion = True",
                "        self.opciones_menu_principal = [\"Jugar\", \"Opciones\", \"Salir\"]",
                "        self.opcion_menu_seleccionada = 0",
                "        self.opciones_menu_pausa = [\"Reanudar\", \"Menú Principal\", \"Salir del Juego\"]",
                "        self.opcion_pausa_seleccionada = 0",
                "        # Opciones disponibles en el menú de configuración.",
                "        self.opciones_menu_opciones = [\"Sonidos\", \"Volver\"]",
                "        # Índice de la opción seleccionada en el menú de configuración.",
                "        self.opcion_opciones_seleccionada = 0",
                "",
                "        # --- Variables de Jugabilidad ---",
                "        self.posiciones_bloqueadas = {}",
                "        self.cuadricula = crear_cuadricula()",
                "        self.pieza_actual = None",
                "        self.siguiente_pieza = None",
                "        self.puntuacion = 0",
                "        self.total_lineas_limpiadas = 0",
                "        self.nivel = 1",
                "        self.velocidad_caida = conf.VELOCIDAD_CAIDA_INICIAL",
                "        self.tiempo_caida = 0",
                "        pygame.key.set_repeat(conf.RETRASO_REPETICION_TECLA, conf.INTERVALO_REPETICION_TECLA)",
                "        # Inicializa/resetea variables de la partida.",
                "        self._reiniciar_variables_juego()",
                "",
                "    def _reiniciar_variables_juego(self):",
                "        \"\"\"Reinicia las variables específicas de una sesión de juego (puntuación, piezas, cuadrícula).\"\"\"",
                "        self.posiciones_bloqueadas = {}",
                "        try:",
                "            # Obtiene la primera pieza y la siguiente.",
                "            self.pieza_actual = obtener_pieza_aleatoria()",
                "            # Asegura que la siguiente no sea igual a la actual inmediatamente.",
                "            self.siguiente_pieza = obtener_pieza_aleatoria(self.pieza_actual.tipo)",
                "        except Exception as e:",
                "            print(f\"ERROR: Falló al obtener las piezas iniciales: {e}\", file=sys.stderr)",
                "            # TODO: Considerar manejo explícito si falla la generación de piezas.",
                "            self.pieza_actual = None",
                "            self.siguiente_pieza = None",
                "        self.puntuacion = 0",
                "        self.total_lineas_limpiadas = 0",
                "        self.nivel = 1",
                "        self.velocidad_caida = self._calcular_velocidad_caida()",
                "        self.tiempo_caida = 0",
                "        # Crea la cuadrícula basada en las (ahora vacías) posiciones bloqueadas.",
                "        self.cuadricula = crear_cuadricula(self.posiciones_bloqueadas)",
                "",
                "    def _calcular_puntuacion(self, lineas_limpiadas):",
                "        \"\"\"Calcula la puntuación basada en las líneas limpiadas a la vez y el nivel actual.\"\"\"",
                "        if lineas_limpiadas <= 0 or lineas_limpiadas not in conf.PUNTOS_POR_LINEA: return 0",
                "        puntuacion_base = conf.PUNTOS_POR_LINEA[lineas_limpiadas]",
                "        incremento_puntuacion = puntuacion_base * self.nivel",
                "        return incremento_puntuacion",
                "",
                "    def _calcular_nivel(self):",
                "        \"\"\"Calcula el nivel actual basado en el total de líneas limpiadas.\"\"\"",
                "        return (self.total_lineas_limpiadas // conf.LINEAS_POR_NIVEL) + 1",
                "",
                "    def _calcular_velocidad_caida(self):",
                "        \"\"\"Calcula la velocidad de caída (tiempo por paso) basado en el nivel actual.\"\"\"",
                "        # Asegura que la velocidad no sea menor que el mínimo definido.",
                "        velocidad = max(conf.VELOCIDAD_CAIDA_MINIMA, conf.VELOCIDAD_CAIDA_INICIAL - (self.nivel - 1) * conf.DECREMENTO_VELOCIDAD_CAIDA)",
                "        return velocidad",
                "",
                "    def _gestionar_entrada(self):",
                "        \"\"\"Procesa todos los eventos de Pygame y actualiza el estado del juego en consecuencia.\"\"\"",
                "        for evento in pygame.event.get():",
                "            if evento.type == pygame.QUIT:",
                "                self.en_ejecucion = False",
                "                return",
                "            # --- Dirigir entrada según el estado ---",
                "            if self.estado_juego == EstadoJuego.MENU: self._gestionar_entrada_menu(evento)",
                "            elif self.estado_juego == EstadoJuego.OPCIONES: self._gestionar_entrada_opciones(evento)",
                "            elif self.estado_juego == EstadoJuego.PAUSADO: self._gestionar_entrada_pausa(evento)",
                "            elif self.estado_juego == EstadoJuego.FIN_JUEGO: self._gestionar_entrada_fin_juego(evento)",
                "            elif self.estado_juego == EstadoJuego.JUGANDO: self._gestionar_entrada_jugando(evento)",
                "",
                "    def _gestionar_entrada_menu(self, evento):",
                "        \"\"\"Gestiona la entrada específica para el estado MENU.\"\"\"",
                "        if evento.type == pygame.KEYDOWN:",
                "            if evento.key == pygame.K_UP:",
                "                # Navega hacia arriba en el menú (circular).",
                "                self.opcion_menu_seleccionada = (self.opcion_menu_seleccionada - 1) % len(self.opciones_menu_principal)",
                "            elif evento.key == pygame.K_DOWN:",
                "                # Navega hacia abajo en el menú (circular).",
                "                self.opcion_menu_seleccionada = (self.opcion_menu_seleccionada + 1) % len(self.opciones_menu_principal)",
                "            elif evento.key == pygame.K_RETURN or evento.key == pygame.K_KP_ENTER:",
                "                # Selecciona la opción actual.",
                "                self._gestionar_seleccion_menu(self.opciones_menu_principal[self.opcion_menu_seleccionada])",
                "            elif evento.key == pygame.K_ESCAPE:",
                "                 # Salir del juego desde el menú.",
                "                 self.en_ejecucion = False",
                "",
                "    def _gestionar_entrada_opciones(self, evento):",
                "        \"\"\"Gestiona la entrada específica para el estado OPCIONES.\"\"\"",
                "        if evento.type == pygame.KEYDOWN:",
                "            if evento.key == pygame.K_UP:",
                "                self.opcion_opciones_seleccionada = (self.opcion_opciones_seleccionada - 1) % len(self.opciones_menu_opciones)",
                "            elif evento.key == pygame.K_DOWN:",
                "                self.opcion_opciones_seleccionada = (self.opcion_opciones_seleccionada + 1) % len(self.opciones_menu_opciones)",
                "            elif evento.key == pygame.K_RETURN or evento.key == pygame.K_KP_ENTER:",
                "                accion_seleccionada = self.opciones_menu_opciones[self.opcion_opciones_seleccionada]",
                "                if accion_seleccionada == \"Sonidos\":",
                "                    # Cambia el estado del flag de sonido.",
                "                    self.es_sonido_activado = not self.es_sonido_activado",
                "                    print(f\"Sonidos Activados: {self.es_sonido_activado}\") # Feedback en consola.",
                "                    # Opcional: Reproducir sonido de confirmación de UI.",
                "                elif accion_seleccionada == \"Volver\":",
                "                    self.estado_juego = EstadoJuego.MENU # Volver al menú principal.",
                "                    # Opcional: Resaltar \"Opciones\" al volver al menú principal.",
                "                    self.opcion_menu_seleccionada = 1",
                "            elif evento.key == pygame.K_ESCAPE:",
                "                 self.estado_juego = EstadoJuego.MENU # Escape también vuelve atrás.",
                "                 # Opcional: Resaltar \"Opciones\" al volver al menú principal.",
                "                 self.opcion_menu_seleccionada = 1",
                "",
                "    def _gestionar_entrada_pausa(self, evento):",
                "        \"\"\"Gestiona la entrada específica para el estado PAUSADO.\"\"\"",
                "        if evento.type == pygame.KEYDOWN:",
                "            if evento.key == pygame.K_UP: self.opcion_pausa_seleccionada = (self.opcion_pausa_seleccionada - 1) % len(self.opciones_menu_pausa)",
                "            elif evento.key == pygame.K_DOWN: self.opcion_pausa_seleccionada = (self.opcion_pausa_seleccionada + 1) % len(self.opciones_menu_pausa)",
                "            elif evento.key == pygame.K_RETURN or evento.key == pygame.K_KP_ENTER: self._gestionar_seleccion_pausa(self.opciones_menu_pausa[self.opcion_pausa_seleccionada])",
                "            elif evento.key == pygame.K_ESCAPE or evento.key == pygame.K_p: self.estado_juego = EstadoJuego.JUGANDO # Reanudar con Escape o P.",
                "",
                "    def _gestionar_entrada_fin_juego(self, evento):",
                "        \"\"\"Gestiona la entrada específica para el estado FIN_JUEGO.\"\"\"",
                "        if evento.type == pygame.KEYDOWN:",
                "            if evento.key == pygame.K_r:",
                "                # Reinicia el juego.",
                "                self._reiniciar_variables_juego()",
                "                self.estado_juego = EstadoJuego.JUGANDO",
                "            elif evento.key == pygame.K_m or evento.key == pygame.K_ESCAPE:",
                "                 # Vuelve al menú principal.",
                "                 self.estado_juego = EstadoJuego.MENU",
                "                 self.opcion_menu_seleccionada = 0 # Resalta \"Jugar\".",
                "",
                "    def _gestionar_entrada_jugando(self, evento):",
                "        \"\"\"Gestiona la entrada específica para el estado JUGANDO.\"\"\"",
                "        if evento.type == pygame.KEYDOWN:",
                "            if evento.key == pygame.K_ESCAPE or evento.key == pygame.K_p:",
                "                # Pausa el juego.",
                "                self.estado_juego = EstadoJuego.PAUSADO",
                "                self.opcion_pausa_seleccionada = 0 # Resalta \"Reanudar\".",
                "                return # Salir para no procesar más teclas en este frame.",
                "            # Solo procesar movimiento si hay una pieza activa.",
                "            if self.pieza_actual:",
                "                if evento.key == pygame.K_LEFT: self._intentar_mover(-1, 0) # Mover izquierda.",
                "                elif evento.key == pygame.K_RIGHT: self._intentar_mover(1, 0) # Mover derecha.",
                "                elif evento.key == pygame.K_DOWN:",
                "                    # Mover abajo (acelerar caída).",
                "                    movido = self._intentar_mover(0, 1)",
                "                    if movido: self.tiempo_caida = 0 # Reiniciar temporizador de caída por gravedad.",
                "                elif evento.key == pygame.K_UP or evento.key == pygame.K_x: self._intentar_rotar(sentido_horario=True) # Rotar horario.",
                "                elif evento.key == pygame.K_z: self._intentar_rotar(sentido_horario=False) # Rotar antihorario.",
                "                elif evento.key == pygame.K_SPACE: self._caida_fuerte() # Caída instantánea.",
                "",
                "    def _gestionar_seleccion_menu(self, seleccion):",
                "        \"\"\"Ejecuta la acción basada en la selección del menú principal.\"\"\"",
                "        if seleccion == \"Jugar\":",
                "            self._reiniciar_variables_juego()",
                "            self.estado_juego = EstadoJuego.JUGANDO",
                "        elif seleccion == \"Opciones\":",
                "            # --- Transición al Menú de Opciones ---",
                "            self.estado_juego = EstadoJuego.OPCIONES",
                "            self.opcion_opciones_seleccionada = 0 # Reiniciar selección en menú de opciones.",
                "        elif seleccion == \"Salir\":",
                "            self.en_ejecucion = False",
                "",
                "    def _gestionar_seleccion_pausa(self, seleccion):",
                "        \"\"\"Ejecuta la acción basada en la selección del menú de pausa.\"\"\"",
                "        if seleccion == \"Reanudar\": self.estado_juego = EstadoJuego.JUGANDO",
                "        elif seleccion == \"Menú Principal\":",
                "            self.estado_juego = EstadoJuego.MENU",
                "            self.opcion_menu_seleccionada = 0 # Resalta \"Jugar\".",
                "        elif seleccion == \"Salir del Juego\": self.en_ejecucion = False",
                "",
                "    def _intentar_mover(self, dx, dy):",
                "        \"\"\"Intenta mover la pieza actual. Devuelve True si tiene éxito.\"\"\"",
                "        if not self.pieza_actual: return False",
                "        # La validación usa self.posiciones_bloqueadas directamente.",
                "        if es_posicion_valida(self.pieza_actual, self.posiciones_bloqueadas,",
                "                             verificar_x=self.pieza_actual.x + dx,",
                "                             verificar_y=self.pieza_actual.y + dy):",
                "            # Actualiza la posición de la pieza si el movimiento es válido.",
                "            self.pieza_actual.x += dx",
                "            self.pieza_actual.y += dy",
                "            return True",
                "        return False # Movimiento inválido.",
                "",
                "    def _intentar_rotar(self, sentido_horario=True):",
                "        \"\"\"Intenta rotar la pieza actual, incluyendo 'wall kicks' básicos.\"\"\"",
                "        if not self.pieza_actual: return",
                "        # Guarda el estado original antes de intentar rotar.",
                "        rotacion_original = self.pieza_actual.rotacion",
                "        x_original = self.pieza_actual.x",
                "        y_original = self.pieza_actual.y",
                "        self.pieza_actual.rotar(sentido_horario)",
                "",
                "        # Comprueba si la nueva rotación es válida en la posición actual.",
                "        if es_posicion_valida(self.pieza_actual, self.posiciones_bloqueadas):",
                "            return # Rotación simple funcionó.",
                "",
                "        # Si la rotación simple falla, intenta 'wall kicks' (desplazamientos).",
                "        # Desplazamientos comunes para intentar encajar la pieza rotada.",
                "        desplazamientos_kick = [(1, 0), (-1, 0), (2, 0), (-2, 0), (0, -1), (0, -2)] # Desplazamientos de 'wall kick' considerados.",
                "        for dx, dy in desplazamientos_kick:",
                "             x_prueba = x_original + dx",
                "             y_prueba = y_original + dy",
                "             if es_posicion_valida(self.pieza_actual, self.posiciones_bloqueadas, verificar_x=x_prueba, verificar_y=y_prueba):",
                "                 # Si una posición con 'kick' es válida, aplica el desplazamiento.",
                "                 self.pieza_actual.x = x_prueba",
                "                 self.pieza_actual.y = y_prueba",
                "                 return # Kick exitoso.",
                "",
                "        # Si la rotación y todos los kicks fallaron, revierte la rotación y posición.",
                "        self.pieza_actual.x = x_original",
                "        self.pieza_actual.y = y_original",
                "        self.pieza_actual.rotacion = rotacion_original",
                "        # Asegura que la forma visual coincida con la rotación revertida.",
                "        self.pieza_actual.forma = self.pieza_actual.formas[rotacion_original]",
                "",
                "    def _caida_fuerte(self):",
                "        \"\"\"Deja caer instantáneamente la pieza y activa el bloqueo.\"\"\"",
                "        if not self.pieza_actual: return",
                "        # calcular_posicion_fantasma usa self.posiciones_bloqueadas.",
                "        fantasma_y = calcular_posicion_fantasma(self.pieza_actual, self.posiciones_bloqueadas)",
                "        distancia_caida = fantasma_y - self.pieza_actual.y",
                "        if distancia_caida > 0:",
                "            self.pieza_actual.y = fantasma_y",
                "            # Fuerza la comprobación de bloqueo en el siguiente ciclo de actualización.",
                "            self.tiempo_caida = self.velocidad_caida",
                "",
                "    def _actualizar(self, dt):",
                "        \"\"\"Actualiza la lógica del juego (principalmente gravedad y bloqueo).\"\"\"",
                "        # Solo actualiza si se está jugando y hay una pieza activa.",
                "        if self.estado_juego != EstadoJuego.JUGANDO or not self.pieza_actual: return",
                "",
                "        self.tiempo_caida += dt # Acumula tiempo delta.",
                "        # Si ha pasado suficiente tiempo para un paso de gravedad.",
                "        if self.tiempo_caida >= self.velocidad_caida:",
                "            self.tiempo_caida -= self.velocidad_caida # Resetea para el próximo paso.",
                "            # Intenta mover la pieza hacia abajo por gravedad.",
                "            if not self._intentar_mover(0, 1):",
                "                # Si no se puede mover hacia abajo, bloquea la pieza y genera la siguiente.",
                "                self._bloquear_y_generar()",
                "",
                "    def _bloquear_y_generar(self):",
                "        \"\"\"Bloquea la pieza, limpia líneas, genera la siguiente, comprueba Fin de Juego y reproduce sonido (condicional).\"\"\"",
                "        if not self.pieza_actual: return",
                "",
                "        # Añade la pieza actual a las posiciones bloqueadas.",
                "        bloquear_pieza(self.pieza_actual, self.posiciones_bloqueadas)",
                "        # Opcional: Actualizar self.cuadricula (visualización basada en bloques).",
                "        self.cuadricula = crear_cuadricula(self.posiciones_bloqueadas)",
                "",
                "        # --- REPRODUCIR SONIDO CONDICIONALMENTE ---",
                "        # Solo reproducir si el sonido existe Y el flag está activado.",
                "        if self.sonido_colocar and self.es_sonido_activado:",
                "            try:",
                "                self.sonido_colocar.play()",
                "            except pygame.error as e:",
                "                 # Advierte si no se pudo reproducir el sonido.",
                "                 print(f\"Advertencia: No se pudo reproducir sonido_colocar: {e}\", file=sys.stderr)",
                "        # --- /REPRODUCIR SONIDO CONDICIONALMENTE ---",
                "",
                "        # Limpia líneas completas y obtiene el nuevo diccionario de posiciones bloqueadas.",
                "        lineas_limpiadas, self.posiciones_bloqueadas = limpiar_lineas(self.posiciones_bloqueadas)",
                "",
                "        if lineas_limpiadas > 0:",
                "            self.puntuacion += self._calcular_puntuacion(lineas_limpiadas)",
                "            self.total_lineas_limpiadas += lineas_limpiadas",
                "            nuevo_nivel = self._calcular_nivel()",
                "            # Si se sube de nivel.",
                "            if nuevo_nivel > self.nivel:",
                "                self.nivel = nuevo_nivel",
                "                self.velocidad_caida = self._calcular_velocidad_caida()",
                "                print(f\"¡Subida de Nivel! Nvl {self.nivel}, Vel {self.velocidad_caida:.3f}s\")",
                "            # Opcional: Recrear self.cuadricula tras limpiar líneas.",
                "            self.cuadricula = crear_cuadricula(self.posiciones_bloqueadas)",
                "            # Opcional: Reproducir sonido de limpieza de línea (condicional).",
                "",
                "        # Prepara la siguiente pieza.",
                "        tipo_ultima_pieza = self.pieza_actual.tipo # Guarda el tipo para evitar repetición inmediata.",
                "        self.pieza_actual = self.siguiente_pieza",
                "        if self.pieza_actual is None:",
                "             # Error: No hay siguiente pieza. Transición a Fin Juego.",
                "             print(\"ERROR: siguiente_pieza era None durante la secuencia de generación.\", file=sys.stderr)",
                "             self.estado_juego = EstadoJuego.FIN_JUEGO",
                "             return",
                "        # Genera una nueva \"siguiente pieza\", evitando el tipo de la que acaba de entrar en juego.",
                "        self.siguiente_pieza = obtener_pieza_aleatoria(tipo_ultima_pieza)",
                "",
                "        # Comprobación de Fin de Juego: Validez de la posición de generación.",
                "        es_generacion_valida = es_posicion_valida(self.pieza_actual, self.posiciones_bloqueadas)",
                "        if not es_generacion_valida:",
                "            self.estado_juego = EstadoJuego.FIN_JUEGO",
                "            print(f\"FIN DEL JUEGO activado! La generación falló debido a solapamiento.\")",
                "            # Opcional: Reproducir sonido de fin de juego (condicional).",
                "",
                "    def _dibujar(self):",
                "        \"\"\"Dibuja todos los elementos del juego basados en el estado.\"\"\"",
                "        self.pantalla.fill(conf.NEGRO) # Limpia la pantalla.",
                "",
                "        # --- Dibujar según el Estado del Juego ---",
                "        if self.estado_juego == EstadoJuego.MENU:",
                "            dibujar_menu_principal(self.pantalla, self.opcion_menu_seleccionada, self.opciones_menu_principal)",
                "        elif self.estado_juego == EstadoJuego.OPCIONES:",
                "            # Se pasa el estado de activación del sonido a la función de dibujo.",
                "            dibujar_menu_opciones(self.pantalla, self.opcion_opciones_seleccionada, self.opciones_menu_opciones, self.es_sonido_activado)",
                "        elif self.estado_juego in [EstadoJuego.JUGANDO, EstadoJuego.PAUSADO, EstadoJuego.FIN_JUEGO]:",
                "            # Dibuja elementos de jugabilidad comunes a estos estados.",
                "            dibujar_lineas_cuadricula(self.pantalla)",
                "            dibujar_borde_campo_juego(self.pantalla)",
                "            # Crea la cuadrícula actual para dibujar los bloques bloqueados.",
                "            cuadricula_actual_para_dibujo = crear_cuadricula(self.posiciones_bloqueadas)",
                "            dibujar_bloques_cuadricula(self.pantalla, cuadricula_actual_para_dibujo)",
                "            dibujar_ui(self.pantalla, self.puntuacion, self.nivel, self.total_lineas_limpiadas)",
                "            if self.siguiente_pieza: dibujar_siguiente_pieza(self.pantalla, self.siguiente_pieza)",
                "",
                "            # Dibuja la pieza actual y fantasma solo si se está jugando.",
                "            if self.estado_juego == EstadoJuego.JUGANDO and self.pieza_actual:",
                "                # Calcula y dibuja la pieza fantasma.",
                "                fantasma_y = calcular_posicion_fantasma(self.pieza_actual, self.posiciones_bloqueadas)",
                "                dibujar_pieza_fantasma(self.pantalla, self.pieza_actual, fantasma_y)",
                "                # Dibuja la pieza activa.",
                "                dibujar_pieza(self.pantalla, self.pieza_actual)",
                "            elif self.estado_juego == EstadoJuego.FIN_JUEGO and self.pieza_actual:",
                "                 # Muestra la pieza que causó el fin del juego en su posición final.",
                "                 dibujar_pieza(self.pantalla, self.pieza_actual)",
                "",
                "            # Dibuja superposiciones si está pausado o es fin de juego.",
                "            if self.estado_juego == EstadoJuego.PAUSADO:",
                "                dibujar_menu_pausa(self.pantalla, self.opcion_pausa_seleccionada, self.opciones_menu_pausa)",
                "            elif self.estado_juego == EstadoJuego.FIN_JUEGO:",
                "                dibujar_fin_juego(self.pantalla) # Superposición de Fin de Juego.",
                "",
                "        pygame.display.flip() # Actualiza la pantalla completa.",
                "",
                "    def ejecutar(self):",
                "        \"\"\"Bucle principal del juego.\"\"\"",
                "        self.en_ejecucion = True",
                "        while self.en_ejecucion:",
                "            # Calcula el tiempo delta (dt) desde el último frame.",
                "            dt = self.reloj.tick(60) / 1000.0",
                "            # Gestiona la entrada del usuario.",
                "            self._gestionar_entrada()",
                "            # Actualiza el estado del juego (movimiento, lógica).",
                "            self._actualizar(dt)",
                "            # Dibuja el frame actual.",
                "            self._dibujar()",
                "",
                "        # Al salir del bucle (self.en_ejecucion es False).",
                "        pygame.quit()",
                "        print(\"Pygame cerrado.\")"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/pieza.py",
                "size_bytes": 5154,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 113,
                "dependencias": [
                    {
                        "path": "tetris/src/configuracion.py",
                        "tipo": "interna"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "random"
                    }
                ]
            },
            "content_lines": [
                "# src/pieza.py",
                "import random",
                "from .configuracion import TETROMINOS, ANCHO_CUADRICULA",
                "",
                "class Pieza:",
                "    \"\"\"Representa una única pieza de Tetris (Tetrominó).\"\"\"",
                "    def __init__(self, indice_tipo_forma, x, y):",
                "        \"\"\"",
                "        Inicializa una Pieza.",
                "",
                "        Args:",
                "            indice_tipo_forma (int): Índice correspondiente a la clave en configuracion.TETROMINOS.",
                "            x (int): Índice inicial de columna de la cuadrícula (borde izquierdo de la matriz de forma).",
                "            y (int): Índice inicial de fila de la cuadrícula (borde superior de la matriz de forma).",
                "        \"\"\"",
                "        if indice_tipo_forma not in TETROMINOS:",
                "            raise ValueError(f\"Índice de tipo de forma inválido: {indice_tipo_forma}\")",
                "",
                "        self.tipo = indice_tipo_forma",
                "        self.datos = TETROMINOS[self.tipo]",
                "        self.color = self.datos['color']",
                "        self.formas = self.datos['formas'] # Lista de matrices de rotación.",
                "        self.rotacion = 0 # Índice en self.formas.",
                "        self.forma = self.formas[self.rotacion] # Matriz de rotación actual.",
                "",
                "        # La posición se refiere a la esquina superior izquierda de la caja delimitadora de la forma en la cuadrícula.",
                "        self.x = x # Índice de columna de la cuadrícula.",
                "        self.y = y # Índice de fila de la cuadrícula.",
                "",
                "    def rotar(self, sentido_horario=True):",
                "        \"\"\"",
                "        Rota la pieza cambiando el índice de rotación actual.",
                "        Actualiza self.forma a la nueva matriz de rotación.",
                "        La lógica de 'wall kick' se maneja externamente (en la clase Juego).",
                "        \"\"\"",
                "        num_rotaciones = len(self.formas)",
                "        # No se puede rotar la pieza O o formas con solo una rotación definida.",
                "        if num_rotaciones <= 1:",
                "            return",
                "",
                "        if sentido_horario:",
                "            self.rotacion = (self.rotacion + 1) % num_rotaciones",
                "        else:",
                "            # El operador % de Python maneja correctamente los números negativos para envolver.",
                "            self.rotacion = (self.rotacion - 1) % num_rotaciones",
                "        self.forma = self.formas[self.rotacion] # Actualiza la forma activa.",
                "",
                "    def obtener_posiciones_bloques(self, cuadricula_x=None, cuadricula_y=None):",
                "        \"\"\"",
                "        Calcula las posiciones absolutas de la cuadrícula (fila, col) de cada bloque",
                "        que compone la pieza en su rotación y posición actuales.",
                "",
                "        Args:",
                "            cuadricula_x (int, optional): Sobrescribe la posición x actual de la pieza. Por defecto, self.x.",
                "            cuadricula_y (int, optional): Sobrescribe la posición y actual de la pieza. Por defecto, self.y.",
                "",
                "        Returns:",
                "            list[tuple[int, int]]: Lista de tuplas (fila, col) para cada bloque.",
                "        \"\"\"",
                "        x_actual = cuadricula_x if cuadricula_x is not None else self.x",
                "        y_actual = cuadricula_y if cuadricula_y is not None else self.y",
                "        forma_a_usar = self.forma",
                "",
                "        posiciones = []",
                "        # Itera sobre la matriz de forma actual.",
                "        for idx_f, fila in enumerate(forma_a_usar):",
                "            for idx_c, celda in enumerate(fila):",
                "                # '1' representa un bloque en la matriz de forma.",
                "                if celda == 1:",
                "                    # Calcula la posición absoluta en la cuadrícula.",
                "                    posiciones.append((y_actual + idx_f, x_actual + idx_c))",
                "        return posiciones",
                "",
                "    def obtener_dimensiones_forma(self):",
                "        \"\"\"Devuelve el alto y ancho de la matriz de forma actual.\"\"\"",
                "        alto = len(self.forma)",
                "        ancho = len(self.forma[0]) if alto > 0 else 0",
                "        return alto, ancho",
                "",
                "# --- Función Fábrica ---",
                "",
                "def obtener_pieza_aleatoria(tipo_ultima_pieza=None):",
                "    \"\"\"",
                "    Crea y devuelve un nuevo objeto Pieza aleatorio.",
                "",
                "    Args:",
                "        tipo_ultima_pieza (int, optional): El índice de tipo de la pieza generada anteriormente,",
                "                                         para evitar la repetición inmediata. Por defecto, None.",
                "",
                "    Returns:",
                "        Pieza: Una instancia de Pieza recién creada.",
                "    \"\"\"",
                "    # Elige un tipo de forma aleatorio.",
                "    tipo_forma = random.randint(0, len(TETROMINOS) - 1)",
                "",
                "    # Asegura que la nueva pieza sea diferente de la última, si se especifica.",
                "    # Implementa un comportamiento simple de \"no repetición inmediata\".",
                "    while tipo_ultima_pieza is not None and tipo_forma == tipo_ultima_pieza:",
                "         tipo_forma = random.randint(0, len(TETROMINOS) - 1)",
                "",
                "    # Calcula la posición inicial para centrar la pieza horizontalmente.",
                "    forma_inicial = TETROMINOS[tipo_forma]['formas'][0] # Usa el primer estado de rotación.",
                "    ancho_forma = len(forma_inicial[0]) if forma_inicial else 0",
                "    # Centra basado en el ancho de la cuadrícula y el ancho de la forma.",
                "    inicio_x = ANCHO_CUADRICULA // 2 - ancho_forma // 2",
                "",
                "    # Comienza la pieza por encima de la cuadrícula visible.",
                "    # Ajusta según la altura de la forma para permitir rotación inicial segura.",
                "    alto_forma = len(forma_inicial)",
                "    # Comienza completamente por encima de los límites visibles de la cuadrícula.",
                "    inicio_y = -alto_forma",
                "",
                "    return Pieza(tipo_forma, inicio_x, inicio_y)"
            ],
            "error_message": null
        },
        {
            "metadata": {
                "path": "tetris/src/sonido.py",
                "size_bytes": 4047,
                "status": "ok",
                "encoding": "utf-8",
                "language": "python",
                "line_count": 95,
                "dependencias": [
                    {
                        "tipo": "biblioteca",
                        "path": "numpy"
                    },
                    {
                        "tipo": "biblioteca",
                        "path": "pygame"
                    },
                    {
                        "tipo": "stdlib",
                        "path": "sys"
                    }
                ]
            },
            "content_lines": [
                "# src/sonido.py",
                "import numpy as np",
                "import pygame",
                "import sys",
                "",
                "# --- Parámetros de Sonido ---",
                "# Parámetros para la generación de sonido.",
                "TASA_MUESTREO = 44100",
                "FRECUENCIA_COLOCAR = 150",
                "DURACION_COLOCAR = 0.08",
                "AMPLITUD_COLOCAR = 5000 # Amplitud del sonido.",
                "",
                "# Caché para el sonido de colocar pieza.",
                "_cache_sonido_colocar = None",
                "",
                "# --- Generador de Ondas ---",
                "def _generar_onda_cuadrada_decreciente(frec, duracion, amplitud, tasa_muestreo, num_canales):",
                "    \"\"\"",
                "    Genera muestras de audio para una onda cuadrada decreciente,",
                "    coincidiendo con el número especificado de canales.",
                "    El sonido se coloca en los dos primeros canales (I/D).",
                "    \"\"\"",
                "    print(f\"Generando onda para {num_canales} canales...\") # Depuración.",
                "    num_muestras = int(tasa_muestreo * duracion)",
                "    puntos_tiempo = np.linspace(0, duracion, num_muestras, endpoint=False)",
                "",
                "    # Generar onda cuadrada mono básica.",
                "    datos_onda_mono = np.sign(np.sin(2 * np.pi * frec * puntos_tiempo))",
                "    # Aplicar decaimiento (lineal al cuadrado para un final más suave).",
                "    decaimiento = np.linspace(1, 0, num_muestras)**2",
                "    datos_onda_mono = amplitud * datos_onda_mono * decaimiento",
                "    # Convertir a array de enteros de 16 bits.",
                "    array_sonido_mono = np.array(datos_onda_mono, dtype=np.int16)",
                "",
                "    # Crear array multicanal inicializado a ceros.",
                "    array_sonido_multi = np.zeros((num_muestras, num_canales), dtype=np.int16)",
                "",
                "    # Colocar los datos del sonido mono en el primer canal (Izquierda).",
                "    if num_canales >= 1:",
                "        array_sonido_multi[:, 0] = array_sonido_mono",
                "",
                "    # Colocar los datos del sonido mono en el segundo canal (Derecha) si está disponible.",
                "    if num_canales >= 2:",
                "        array_sonido_multi[:, 1] = array_sonido_mono",
                "",
                "    # Los canales 3 a num_canales permanecen en silencio (ceros).",
                "",
                "    print(f\"Forma del array generado: {array_sonido_multi.shape}\") # Depuración.",
                "    return array_sonido_multi",
                "",
                "# --- Creación de Sonido ---",
                "def crear_sonido_colocar():",
                "    \"\"\"",
                "    Genera y devuelve un objeto pygame.mixer.Sound para el efecto de colocación de pieza.",
                "    Determina los canales reales del mezclador y genera datos de sonido compatibles.",
                "    Cachea el resultado. Asume que pygame.mixer ha sido inicializado previamente.",
                "    \"\"\"",
                "    global _cache_sonido_colocar",
                "    # Devuelve el sonido cacheado si ya existe.",
                "    if _cache_sonido_colocar is not None:",
                "        return _cache_sonido_colocar",
                "",
                "    print(\"Intentando crear efecto de sonido 'colocar'...\")",
                "    try:",
                "        # --- Obtener Configuración Real del Mezclador ---",
                "        config_mezclador = pygame.mixer.get_init()",
                "        if not config_mezclador:",
                "            print(\"ERROR: ¡El mezclador no está inicializado al intentar crear sonido!\", file=sys.stderr)",
                "            return None",
                "",
                "        # Desempaqueta la configuración real del mezclador.",
                "        frec_real, formato_real, canales_reales = config_mezclador",
                "        print(f\"Mezclador reportó config: Frec={frec_real}, Formato={formato_real}, Canales={canales_reales}\")",
                "",
                "        # --- Generar Datos de Sonido Coincidentes con Canales Reales ---",
                "        array_sonido = _generar_onda_cuadrada_decreciente(",
                "            frec=FRECUENCIA_COLOCAR,",
                "            duracion=DURACION_COLOCAR,",
                "            amplitud=AMPLITUD_COLOCAR,",
                "            tasa_muestreo=frec_real, # Usa frecuencia real del mezclador.",
                "            num_canales=canales_reales # Usa canales reales del mezclador.",
                "        )",
                "",
                "        # Crear el objeto de sonido desde el array numpy potencialmente multicanal.",
                "        sonido = pygame.sndarray.make_sound(array_sonido)",
                "        _cache_sonido_colocar = sonido # Guarda en caché.",
                "        print(\"Sonido 'Colocar' generado con éxito.\")",
                "        return sonido",
                "",
                "    except pygame.error as error_pg:",
                "        print(f\"ERROR: Error de Pygame generando sonido colocar: {error_pg}\", file=sys.stderr)",
                "        return None",
                "    except Exception as e:",
                "        print(f\"ERROR: Excepción general generando sonido colocar: {e}\", file=sys.stderr)",
                "        return None"
            ],
            "error_message": null
        }
    ]
}